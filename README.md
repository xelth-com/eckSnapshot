
# eckSnapshot (v5.0.3)

A lightweight, platform-independent CLI for creating focused, AI-ready project snapshots.

---

## ‚ö†Ô∏è NPM Publishing Discontinued | –ü—É–±–ª–∏–∫–∞—Ü–∏—è –≤ NPM –ø—Ä–µ–∫—Ä–∞—â–µ–Ω–∞

**EN:** We've stopped publishing to npm due to their excessive security requirements (10-second tokens, 10-factor authentication, and constant token revocations). If you're interested in this project, **all updates will be released exclusively on GitHub**. Install directly from the repository.

**RU:** npm –º–æ–∂–µ—Ç –∏–¥—Ç–∏ –ª–µ—Å–æ–º. –ö–æ–º—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ - —Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –≥–∏—Ç–µ.

**GitHub Repository:** https://github.com/xelth-com/eckSnapshot

---

`eckSnapshot` is a powerful command-line tool designed to solve a critical problem in AI-assisted development: providing clear, complete, and focused context to Large Language Models (LLMs). It allows you to package an entire project codebase‚Äîor just specific parts of it‚Äîinto a single, clean text file.

This tool is built for a modern workflow where you act as the architect, guiding the overall strategy, while AI agents handle the detailed implementation.

## The Core Workflow

`eckSnapshot` is designed to support a two-part AI workflow for maximum efficiency and quality:

1.  **The Architect LLM (Gemini, ChatGPT/GPT-4, Grok):** A model with a large context window. You provide it with a snapshot of your project, and it analyzes the codebase to create a high-level plan for new features or refactoring.
2.  **The Coder LLM (Claude Code, Minimax):** A model specialized in writing and modifying code. It takes the detailed instructions generated by the Architect and performs the hands-on coding tasks.

## Requirements

1.  **Node.js** (v18.x or higher).
2.  **An AI Assistant CLI (at least one of the following is required):**
    *   **Claude Code:** An active **Claude Pro** subscription and the `claude-code` CLI installed.
    *   **Minimax:** Minimax API access and CLI configured.
3.  **Gemini (recommended):** For the Architect role with large context windows, Gemini API access is highly recommended.

## Installation

Install `eckSnapshot` globally directly from GitHub:

```bash
npm install -g github:xelth-com/eckSnapshot
```

Or clone and link locally:

```bash
git clone https://github.com/xelth-com/eckSnapshot.git
cd eckSnapshot
npm install
npm link
```

Once installed, you can run the tool using the `eck-snapshot` command from any directory.

## Getting Started: Full Snapshot Workflow

This is the primary workflow for creating complete snapshots of your project.

#### Step 1: Create a Full Project Snapshot

This is your primary command. It scans your project and packs all relevant code into a single file.

> **Usage:**
> ```bash
> dimi@xelth:/mnt/c/Users/xelth/myProject$ eck-snapshot
> ```

*   **What it does:** Creates a file like `myProject_snapshot_... .md` in the `.eck/snapshots/` directory. This file contains your project's directory structure and the complete code. You can now pass this file to your Architect LLM for analysis.

#### Step 2: Working with Profiles for Large Projects

When your project is too large for an LLM's context window, you can use **profiles** to slice it into logical parts. There are two methods:

##### Option A: Auto-Detection (Quick but can be fragile on huge projects)

Uses local AI (Claude CLI) to automatically analyze your project and suggest profiles.

> **Usage:**
> ```bash
> eck-snapshot profile-detect
> ```

*   **Output Example:**
    ```
    ‚ú® Detected Profiles:
    ---------------------------
      - cli
      - services
      - core
      - templates
      - docs
      - config
    ```
*   **What it does:** Analyzes your project and saves these logical groupings into a `.eck/profiles.json` file.
*   **Limitation:** Can fail on very large projects (thousands of files) because the directory tree becomes too large for the local Claude CLI.

##### Option B: Manual Guide (Reliable for massive projects)

Generates a guide file that you can use with any AI assistant that has a large context window (Gemini 1.5 Pro, GPT-4, etc.). This is the **recommended approach for large monorepos**.

> **Usage:**
> ```bash
> eck-snapshot generate-profile-guide
> ```

**What happens:**
1. Creates `.eck/profile_generation_guide.md` containing:
   - A ready-to-use prompt for the AI
   - Your complete project directory tree
2. You open this file and copy its contents
3. Paste into your preferred AI assistant (web UI with large context)
4. The AI analyzes the structure and returns a JSON with suggested profiles
5. Save the JSON to `.eck/profiles.json`

**Example workflow:**
```bash
# 1. Generate the guide
eck-snapshot generate-profile-guide

# 2. Open the guide file
cat .eck/profile_generation_guide.md

# 3. Copy the prompt and directory tree, paste into Gemini/ChatGPT
# 4. AI returns something like:
# {
#   "backend": {
#     "include": ["src/api/**", "src/database/**"],
#     "exclude": ["**/*.test.js"]
#   },
#   "frontend": {
#     "include": ["src/components/**", "src/pages/**"],
#     "exclude": ["**/*.spec.js"]
#   }
# }

# 5. Save the JSON to .eck/profiles.json
# (manually create/edit the file)

# 6. Now you can use the profiles
eck-snapshot --profile backend
```

**Why use this instead of auto-detect?**
- Works with projects of any size (no local context limits)
- Uses powerful web-based LLMs with large context windows
- More reliable - doesn't crash on huge directory trees
- You can review and edit the suggestions before saving

#### Step 3: Use Profiles to Create Focused Snapshots

The `--profile` option gives you powerful control over what goes into a snapshot. You can combine profiles, exclude files, and even use ad-hoc patterns.

> **Example 1: Combine and Exclude Profiles**
>
> Create a snapshot of the core logic, services, and CLI, but exclude all documentation and configuration files.
> ```bash
> eck-snapshot --profile "core,services,cli,-docs,-config"
> ```

> **Example 2: Use Ad-Hoc Glob Patterns**
>
> Include all `.js` files in the `src` directory but exclude all test files, without using a pre-defined profile.
> ```bash
> eck-snapshot --profile "src/**/*.js,-**/*.test.js"
> ```
> *Note: Quotes are required when using complex patterns with wildcards (`*`) or commas.*

#### Step 4: Intelligently Prune a Snapshot

If a snapshot is still too large, `prune` uses AI to shrink it to a target size, keeping only the most important files for understanding the code.

> **Usage:**
> ```bash
> eck-snapshot prune myProject_snapshot.md --target-size 500KB
> ```

#### Step 5 (Alternative): Truncate Files by Line Count

A faster, non-AI method to reduce snapshot size. This command keeps only the top N lines of each file, which is useful for a high-level architectural overview.

> **Usage:**
> ```bash
> eck-snapshot --max-lines-per-file 200
> ```

## Skeleton Workflow (Advanced for Large Projects)

The skeleton workflow is optimized for web-based LLMs (Gemini, ChatGPT) with large context windows. It uses a three-step approach for maximum compression:

### 1. Initial Context (Maximum Compression)

Create a lightweight map of your entire project where function/method bodies are hidden, showing only signatures and structure.

```bash
eck-snapshot --skeleton
```

This generates `.eck/snapshots/<name>_sk.md` - a compressed overview that fits even large monoliths into the context window.

### 2. Lazy Loading (On-Demand Details)

When the AI needs implementation details, use the `show` command to display specific files:

```bash
eck-snapshot show src/auth.js src/utils/hash.js
```

Copy-paste the output back to your AI chat.

### 3. Incremental Updates

After making changes, use the `update` command (see section below) to send only what changed.

## Incremental Updates: The `update` Command

The `update` command is a powerful feature that creates **delta snapshots** containing only the files that changed since your last full snapshot. This is essential for maintaining AI context efficiently during active development.

### How It Works

1. **Anchor Point:** When you create a full snapshot (with `eck-snapshot` or `eck-snapshot --skeleton`), the current git commit hash is saved as an "anchor" in `.eck/.snapshot-anchor`.

2. **Change Detection:** The `update` command compares your current working directory against this anchor to identify all modified, added, or deleted files.

3. **Delta Generation:** It creates a new snapshot file containing:
   - Only the changed files (with full content)
   - A git diff showing all changes for context
   - Clear instructions for the AI to merge these changes with the base snapshot

### Usage

```bash
eck-snapshot update
```

This generates `.eck/snapshots/update_<timestamp>.md`.

### When to Use

- **During active development:** After making changes based on AI suggestions, send an update instead of the entire codebase
- **Iterative workflows:** Keep the AI synchronized with your latest code without re-uploading everything
- **Large projects:** Especially valuable when the full snapshot is large - updates are typically much smaller

### Important Notes

- You must create a full snapshot first before using `update`
- Each update is self-contained - send only the latest update to the AI, not all previous updates
- The AI is instructed to "merge" the update over the base snapshot mentally
- Works with both regular and skeleton snapshots

## Auxiliary Commands

*   `restore <snapshot_file>`: Recreates a project's file structure from a snapshot.
*   `detect`: Shows how `eckSnapshot` has identified your project type and what default file filters are being applied.
*   `ask-claude`: Directly delegate a task to your configured Claude Code CLI agent from the command line.
*   `setup-gemini`: A utility to automatically configure integration with the `gemini-cli`.
*   `show <file1> <file2> ...`: Display full content of specific files (used for lazy loading in skeleton workflow).

For a full list of commands and options, run `eck-snapshot --help`.

## ü§ñ MiniMax M2.1 Integration

eckSnapshot supports **two ways** to integrate with MiniMax M2.1, a cost-effective AI model with a huge context window:

### Method 1: Supervisor-Worker Mode (Hybrid)
Claude Code acts as the Supervisor, delegating heavy tasks to MiniMax via MCP. Best for interactive development.
- **Setup:** [Hybrid Mode Guide](./MINIMAX_INTEGRATION.md#method-1-supervisor-worker-mode-hybrid-architecture)
- **Cost:** Moderate (Claude + MiniMax)
- **Complexity:** Requires MCP setup

### Method 2: Standalone Mode
Use MiniMax directly as your primary AI assistant. Best for batch processing and bulk refactoring.
- **Setup:** [Standalone Guide](./MINIMAX_INTEGRATION.md#method-2-standalone-mode-direct-minimax-usage)
- **Cost:** Low (MiniMax only)
- **Complexity:** Simple shell alias

üëâ **[Read the Full Integration Guide](./MINIMAX_INTEGRATION.md)** for detailed setup instructions and comparison.

## Experimental Features

‚ö†Ô∏è **juniorArchitect**: This feature is currently under development and not yet functional. It's intended to provide automated architectural analysis and suggestions. Contributions to complete this feature are welcome!

## License

This project is licensed under the MIT License.