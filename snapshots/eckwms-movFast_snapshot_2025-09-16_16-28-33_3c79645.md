
# AI Instructions

## 1. How to Read This Snapshot

This document is a self-contained, single-file snapshot of the **eckwms-movFast** software repository, generated by the `eck-snapshot` tool on **2025-09-16T16:28:33.362Z**. It is designed to provide a Large Language Model (LLM) with the complete context of a project.

* **Source of Truth:** Treat this snapshot as the complete and authoritative source code.
* **Structure:** The file contains a **Directory Structure** tree, followed by the full content of each file, demarcated by `--- File: /path/to/file ---` headers.

**Snapshot Stats:**
- **Files Included:** 45
- **Total Files in Repo:** 57


## Project-Specific Manifest (.eck Directory)

This project includes a `.eck` directory with specific context and configuration:

### Project Context

# Project Overview

## Description
Brief description of what this project does and its main purpose.

## Architecture
High-level overview of the system architecture, key components, and how they interact.

## Key Technologies
- Technology 1
- Technology 2
- Technology 3

## Important Notes
Any crucial information that developers should know when working on this project.

### Operations Guide

# Common Operations

## Development Setup
```bash
# Setup commands
npm install
# or yarn install
```

## Running the Project
```bash
# Development mode
npm run dev

# Production build
npm run build
```

## Testing
```bash
# Run tests
npm test

# Run tests in watch mode
npm run test:watch
```

## Deployment
```bash
# Deployment commands
npm run deploy
```

## Troubleshooting
Common issues and their solutions.

### Development Journal

# Development Journal

## Recent Changes
Track significant changes, decisions, and progress here.


## Git Commit Workflow

**IMPORTANT**: This project is a Git repository. After successfully completing any development task, you MUST propose a Git commit as the final step.

### Commit Process
1. **Review Changes**: Before committing, briefly summarize what was accomplished
2. **Stage Files**: Include `git add .` or specific files in your command block
3. **Create Commit**: Use a clear, descriptive commit message following this format:
   - Start with the task context (e.g., "feat:", "fix:", "docs:", "refactor:")
   - Include the task_id from your command block for traceability
   - Keep it under 50 characters for the first line
   - Add detailed description if needed

### Example Git Commands to Include
```bash
git add .
git commit -m "feat: implement user authentication system

Task ID: auth-system-implementation-1
- Added login/register endpoints
- Implemented JWT token validation
- Added user session management"
```

### When to Commit
- After completing any feature implementation
- After fixing bugs or issues
- After refactoring or code improvements
- After adding tests or documentation
- Before major architectural changes

**Remember**: Always include the Git commit step in your final command block to ensure proper version control and project history.

---

### YYYY-MM-DD - Project Started
- Initial project setup
- Added basic structure

**Important**: Use this manifest information when formulating technical plans and briefing execution agents. The context, operations guide, and journal provide crucial project-specific knowledge that should inform your decisions.

---

---

## 2. Your Core Operational Workflow

You are the Project Manager and Solution Architect AI. Your primary goal is to translate user requests into technical plans and then generate precise commands for code-execution AI agents.

### PROJECT OVERVIEW
- **Project:** eckwms-movFast
- **Description:** A monorepo POS system with Electron frontend and Node.js backend.

### PROJECT-SPECIFIC MANIFEST (.eck Directory)

Some projects include a `.eck` directory containing project-specific context and configuration. When present, this directory provides crucial information that should inform all your technical decisions:

- **CONTEXT.md**: Project-specific background, architecture notes, and important context
- **OPERATIONS.md**: Common operations, deployment procedures, and workflow guidance
- **JOURNAL.md**: Development history, recent changes, and ongoing notes
- **ENVIRONMENT.md**: Environment-specific settings that override auto-detected values (YAML format)

**CRITICAL**: Always prioritize information from the .eck manifest when it conflicts with auto-detected project settings. Use this context when formulating plans and briefing execution agents.

### CORE WORKFLOW: The Interactive Command Cycle
1. **Check Environment:** Request ENV scan from agent first
2. **Analyze User Request:** Understand the user's goal in their native language.
3. **Formulate a Plan:** Create a high-level technical plan appropriate for the detected environment and .eck manifest context.
4. **Propose & Await Confirmation:** Present the plan to the user in their language and ask for approval to generate the command. **CRITICAL: Stop and wait for the user's response. Do NOT generate the command block at this stage.**
5. **Generate Command on Demand:** This is the execution step, triggered ONLY by a positive user response.
   - **On Approval:** If the user confirms the plan (e.g., "yes", "proceed") or provides a minor correction, your *next response* must be **only the command block**. Do not include any conversational text.
   - **On Direct Order:** If the user explicitly asks for the command (e.g., "make the command for Claude now") and you have all the necessary information, you may skip step 3 and directly generate the command block.
6. **Review & Report:** After the command is executed, analyze the results and report back to the user in their language.
7. **Iterate:** Continue the cycle based on user feedback.

### COMMUNICATION PROTOCOL
- **User Interaction:** ALWAYS communicate with the user in the language they use.
- **Agent Commands:** ALWAYS formulate the JSON payload and technical instructions for the execution agent in **ENGLISH** to ensure technical accuracy.
- **Context Integration:** When briefing agents, include relevant information from the .eck manifest to provide better context.

### AVAILABLE EXECUTION AGENTS
You can command multiple specialized agents. **YOU must choose the most appropriate agent** based on the task requirements and target environment:


### Local Development Agent (AGENT_LOCAL_DEV) (ID: "local_dev")
- **Description:** Cross-platform local development with SQLite
- **GUI Support:** Yes
- **Capabilities:** npm install, npm run dev, npm run dev:backend, git operations, sqlite3 commands, electron debug, file editing, testing commands, browser automation
- **Restrictions:** no PM2 commands, no PostgreSQL production operations, no systemctl, no production deployments

### Production Server Agent (AGENT_PROD_SERVER) (ID: "production_server")
- **Description:** Linux production server with PostgreSQL and PM2, with development capabilities
- **GUI Support:** No (Headless)
- **Capabilities:** pm2 restart/reload/stop/start, postgresql queries, knex migrations --env production, systemctl, log analysis, nginx operations, deployment scripts, file editing, npm install, git operations
- **Restrictions:** no electron, no GUI apps, no direct DB schema changes without migrations, always backup before migrations

### Android WSL Development Agent (AGENT_ANDROID_WSL) (ID: "android_wsl_dev")
- **Description:** Android development in Windows Subsystem for Linux with Gradle and ADB support
- **GUI Support:** No (Headless)
- **Capabilities:** ./gradlew build, ./gradlew assembleDebug, ./gradlew assembleRelease, ./gradlew clean, ./gradlew lint, ./gradlew test, adb devices, adb install, adb logcat, adb shell, git operations, file editing, gradle tasks, gradle wrapper operations
- **Restrictions:** no direct GUI access (Android Studio), requires /mnt/c/ path for Windows file system access, no Android emulator control (emulator runs on Windows host), limited USB device access through WSL, no hardware debugging interfaces


### COMMAND BLOCK FORMAT
To ensure error-free execution, all tasks for agents must be presented in a special block with a "Copy" button. **IMPORTANT:** You MUST analyze the task and choose the appropriate agent by its ID, then fill in the agent information:

**MANDATORY STRUCTURED LOGGING**: Every command payload MUST include 'post_execution_steps' with a structured 'journal_entry' object. The execution agent will use these fields to generate both a conventional Git commit message and a Markdown journal entry with YAML Frontmatter for machine-readable project history.

**Journal Entry Fields**:
- **type**: Conventional commit type (feat, fix, docs, style, refactor, test, chore)
- **scope**: Functional area affected (e.g., auth, ui, api, database)
- **summary**: Brief description of the change (becomes commit subject)
- **details**: Comprehensive explanation for the project journal

```json
{
  "target_agent": "local_dev",
  "agent_environment": "Development environment with full GUI support and development tools",
  "command_for_agent": "apply_code_changes",
  "task_id": "unique-task-id",
  "payload": {
    "objective": "Brief, clear task description",
    "context": "Why this change is needed - include relevant .eck manifest context",
    "files_to_modify": [
      {
        "path": "exact/file/path.js",
        "action": "specific action (add, modify, replace, delete)",
        "location": "line numbers, function name, or search pattern",
        "details": "precise description of the change"
      }
    ],
    "new_files": [
      {
        "path": "path/to/new/file.js",
        "content_type": "javascript/json/markdown/config",
        "purpose": "why this file is needed"
      }
    ],
    "dependencies": {
      "install": ["package-name@version"],
      "remove": ["old-package-name"]
    },
    "validation_steps": [
      "npm run test",
      "node index.js --help",
      "specific command to verify functionality"
    ],
    "expected_outcome": "what should work after changes",
    "post_execution_steps": {
      "journal_entry": {
        "type": "feat",
        "scope": "authentication",
        "summary": "Brief description of what was accomplished",
        "details": "Detailed explanation of changes, impacts, and technical notes"
      }
    }
  }
}
```

---

## Directory Structure

```
├── .eck/
├── .gradle/
│   ├── 8.11.1/
│   │   ├── checksums/
│   │   ├── executionHistory/
│   │   ├── expanded/
│   │   ├── fileChanges/
│   │   ├── fileHashes/
│   │   └── vcsMetadata/
│   ├── 8.13/
│   │   ├── checksums/
│   │   ├── expanded/
│   │   ├── fileChanges/
│   │   ├── fileHashes/
│   │   └── vcsMetadata/
│   └── vcs-1/
├── .kotlin/
│   └── sessions/
├── app/
│   ├── libs/
│   ├── src/
│   │   ├── androidTest/
│   │   │   └── java/
│   │   │       └── com/
│   │   │           └── xelth/
│   │   │               └── eckwms_movfast/
│   │   │                   └── ExampleInstrumentedTest.kt
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   └── com/
│   │   │   │       └── xelth/
│   │   │   │           └── eckwms_movfast/
│   │   │   │               ├── api/
│   │   │   │               │   └── ScanApiService.kt
│   │   │   │               ├── diagnostics/
│   │   │   │               │   ├── ScannerApiTester.kt
│   │   │   │               │   └── ScannerImageDiagnostics.kt
│   │   │   │               ├── scanners/
│   │   │   │               │   ├── ScannerManager.kt
│   │   │   │               │   ├── ScannerManagerImageExtensions.kt
│   │   │   │               │   └── XCScannerWrapper.kt
│   │   │   │               ├── ui/
│   │   │   │               │   ├── navigation/
│   │   │   │               │   │   └── Navigation.kt
│   │   │   │               │   ├── screens/
│   │   │   │               │   │   ├── ApiTestHelpDialog.kt
│   │   │   │               │   │   ├── ImageViewerScreen.kt
│   │   │   │               │   │   ├── ScannedImageScreen.kt
│   │   │   │               │   │   ├── ScannerScreen.kt
│   │   │   │               │   │   ├── ScannerSettingsScreen.kt
│   │   │   │               │   │   └── SimpleImageViewerSection.kt
│   │   │   │               │   └── theme/
│   │   │   │               │       ├── Color.kt
│   │   │   │               │       ├── Theme.kt
│   │   │   │               │       └── Type.kt
│   │   │   │               ├── utils/
│   │   │   │               │   └── PermissionUtils.kt
│   │   │   │               ├── EckwmsApp.kt
│   │   │   │               ├── MainActivity.kt
│   │   │   │               └── ScannerActivity.kt
│   │   │   ├── res/
│   │   │   │   ├── drawable/
│   │   │   │   │   ├── ic_launcher_background.xml
│   │   │   │   │   └── ic_launcher_foreground.xml
│   │   │   │   ├── mipmap-anydpi/
│   │   │   │   │   ├── ic_launcher_round.xml
│   │   │   │   │   └── ic_launcher.xml
│   │   │   │   ├── mipmap-hdpi/
│   │   │   │   │   ├── ic_launcher_round.webp
│   │   │   │   │   └── ic_launcher.webp
│   │   │   │   ├── mipmap-mdpi/
│   │   │   │   │   ├── ic_launcher_round.webp
│   │   │   │   │   └── ic_launcher.webp
│   │   │   │   ├── mipmap-xhdpi/
│   │   │   │   │   ├── ic_launcher_round.webp
│   │   │   │   │   └── ic_launcher.webp
│   │   │   │   ├── mipmap-xxhdpi/
│   │   │   │   │   ├── ic_launcher_round.webp
│   │   │   │   │   └── ic_launcher.webp
│   │   │   │   ├── mipmap-xxxhdpi/
│   │   │   │   │   ├── ic_launcher_round.webp
│   │   │   │   │   └── ic_launcher.webp
│   │   │   │   ├── values/
│   │   │   │   │   ├── colors.xml
│   │   │   │   │   ├── strings.xml
│   │   │   │   │   └── themes.xml
│   │   │   │   └── xml/
│   │   │   │       ├── backup_rules.xml
│   │   │   │       └── data_extraction_rules.xml
│   │   │   └── AndroidManifest.xml
│   │   └── test/
│   │       └── java/
│   │           └── com/
│   │               └── xelth/
│   │                   └── eckwms_movfast/
│   │                       └── ExampleUnitTest.kt
│   └── proguard-rules.pro
├── gradle/
│   ├── wrapper/
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   └── libs.versions.toml
├── gradle.properties
├── gradlew
├── gradlew.bat
├── LICENSE
├── README.md
└── settings.gradle.kts
```

--- File: /.gitignore ---

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Log/OS Files
*.log

# Android Studio generated files and folders
captures/
.externalNativeBuild/
.cxx/
*.apk
output.json

# IntelliJ
*.iml
.idea/
misc.xml
deploymentTargetDropDown.xml
render.experimental.xml

# Keystore files
*.jks
*.keystore

# Google Services (e.g. APIs or Firebase)
google-services.json

# Android Profiling
*.hprof

# Added by eck-snapshot to prevent committing snapshots
snapshots/


--- File: /LICENSE ---

MIT License

Copyright (c) 2025 Dmytro Surovtsev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


--- File: /README.md ---

# eckwms-movFast
ECKWMS client for the movFast device.


--- File: /app/.gitignore ---

/build

--- File: /app/build.gradle.kts ---

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
}

android {
    namespace = "com.xelth.eckwms_movfast"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.xelth.eckwms_movfast"
        minSdk = 33
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        compose = true
    }
}

dependencies {

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)

    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    implementation(files("libs/xcscanner_v1.1.17-release.aar"))
    implementation("com.google.accompanist:accompanist-permissions:0.31.1-alpha")

    // Jetpack Compose Navigation
    implementation("androidx.navigation:navigation-compose:2.7.0")
    // Your existing Compose dependencies
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.material:material")
    implementation("androidx.compose.ui:ui-tooling-preview")
    // Для интеграции LiveData с Compose
    implementation("androidx.compose.runtime:runtime-livedata:1.5.4")
    implementation("io.coil-kt:coil-compose:2.5.0")
}

--- File: /app/proguard-rules.pro ---

# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

--- File: /app/src/androidTest/java/com/xelth/eckwms_movfast/ExampleInstrumentedTest.kt ---

package com.xelth.eckwms_movfast

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.xelth.eckwms_movfast", appContext.packageName)
    }
}

--- File: /app/src/main/AndroidManifest.xml ---

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-feature android:name="android.hardware.camera" android:required="false" />
    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />

    <application
        android:name=".EckwmsApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.EckwmsmovFast"
        android:usesCleartextTraffic="true"
        tools:targetApi="33">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.EckwmsmovFast">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Добавленная активность для сканера -->
        <activity
            android:name=".ScannerActivity"
            android:exported="false"
            android:theme="@style/Theme.EckwmsmovFast" />
    </application>
</manifest>

--- File: /app/src/main/java/com/xelth/eckwms_movfast/EckwmsApp.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/EckwmsApp.kt
// Обновлено с добавлением автоматического тестирования API при запуске
package com.xelth.eckwms_movfast

import android.app.Application
import android.util.Log
import com.xelth.eckwms_movfast.diagnostics.ScannerApiTester
import com.xelth.eckwms_movfast.scanners.ScannerManager

class EckwmsApp : Application() {
    private val TAG = "EckwmsApp"

    // Ссылка на ScannerManager для удобного доступа
    lateinit var scannerManager: ScannerManager
        private set

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Приложение запускается...")

        // Инициализация ScannerManager
        scannerManager = ScannerManager.getInstance(this)
        scannerManager.initialize()

        // Запуск автоматического тестирования API сканера при запуске
        Log.d(TAG, "Запуск автоматического тестирования API сканера...")
        ScannerApiTester(scannerManager).testAndLogAllApiFunctions()
        Log.d(TAG, "Автоматическое тестирование API сканера завершено")
    }

    override fun onTerminate() {
        super.onTerminate()

        // Освобождение ресурсов сканера
        scannerManager.cleanup()
        Log.d(TAG, "Приложение завершает работу")
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/MainActivity.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/MainActivity.kt
package com.xelth.eckwms_movfast

import android.content.Intent
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.xelth.eckwms_movfast.api.ScanApiService
import com.xelth.eckwms_movfast.api.ScanResult
import com.xelth.eckwms_movfast.scanners.ScannerManager
import com.xelth.eckwms_movfast.ui.screens.SimpleImageViewerSection
import com.xelth.eckwms_movfast.ui.theme.EckwmsmovFastTheme
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject

class MainActivity : ComponentActivity() {
    private val TAG = "MainActivity"

    // Ссылка на ScannerManager
    private lateinit var scannerManager: ScannerManager

    // Ссылка на сервис API сканирования
    private lateinit var scanApiService: ScanApiService

    // LiveData для деталей результата обработки сервером
    private val _scanResultDetails = MutableLiveData<String>()
    private val scanResultDetails: LiveData<String> = _scanResultDetails

    // LiveData для статуса отправки на сервер
    private val _serverRequestStatus = MutableLiveData<RequestStatus>()
    private val serverRequestStatus: LiveData<RequestStatus> = _serverRequestStatus

    // Added LiveData for image URLs
    private val _imageUrls = MutableLiveData<List<String>>(emptyList())
    private val imageUrls: LiveData<List<String>> = _imageUrls

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        // Получение ScannerManager из приложения
        scannerManager = (application as EckwmsApp).scannerManager

        // Инициализация ScanApiService
        scanApiService = ScanApiService(this)
        // Предоставляем ScanApiService доступ к ScannerManager для получения типа штрих-кодов
        scanApiService.setScannerManager(scannerManager)

        // Наблюдаем за результатами сканирования от ScannerManager
        scannerManager.scanResult.observeForever { barcode ->
            if (barcode != null && barcode.isNotEmpty()) {
                Log.d(TAG, "Scanner detected barcode: $barcode")
                handleScannedBarcode(barcode)
            }
        }

        setContent {
            EckwmsmovFastTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    // Наблюдаем за результатами сканирования через LiveData
                    val latestResultDetails by scanResultDetails.observeAsState()
                    val latestRequestStatus by serverRequestStatus.observeAsState()
                    val serverImageUrls by imageUrls.observeAsState(emptyList())

                    MainContent(
                        scannedBarcode = null,
                        resultDetails = latestResultDetails,
                        requestStatus = latestRequestStatus,
                        imageUrls = serverImageUrls,
                        modifier = Modifier.padding(innerPadding),
                        onOpenScannerSettings = {
                            // Запускаем ScannerActivity
                            val intent = Intent(this@MainActivity, ScannerActivity::class.java)
                            startActivity(intent)
                        }
                    )
                }
            }
        }
    }

    /**
     * Обработка отсканированного штрих-кода и отправка на сервер
     */
    private fun handleScannedBarcode(barcode: String) {
        // Обновляем статус отправки
        _serverRequestStatus.postValue(RequestStatus.LOADING)
        _scanResultDetails.postValue("")
        _imageUrls.postValue(emptyList()) // Clear previous images

        // Отправляем на сервер
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Log.d(TAG, "Sending barcode to server: $barcode")
                val result = scanApiService.processScan(barcode)

                withContext(Dispatchers.Main) {
                    when (result) {
                        is ScanResult.Success -> {
                            // Обрабатываем успешный результат
                            Log.d(TAG, "Server response success: ${result.data}")
                            _serverRequestStatus.postValue(RequestStatus.SUCCESS)

                            // Update image URLs if available
                            if (result.imageUrls.isNotEmpty()) {
                                Log.d(TAG, "Received ${result.imageUrls.size} images from server")
                                _imageUrls.postValue(result.imageUrls)
                            }

                            try {
                                // Формируем удобный для отображения текст
                                val formattedMessage = formatSuccessMessage(result)
                                _scanResultDetails.postValue(formattedMessage)
                            } catch (e: Exception) {
                                Log.e(TAG, "Error parsing success response: ${e.message}")
                                _scanResultDetails.postValue("Response received but error parsing details: ${e.message}")
                            }
                        }
                        is ScanResult.Error -> {
                            // Обрабатываем ошибку
                            Log.e(TAG, "Server response error: ${result.message}")
                            _serverRequestStatus.postValue(RequestStatus.ERROR)
                            _scanResultDetails.postValue("Error: ${result.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error sending to server", e)
                withContext(Dispatchers.Main) {
                    _serverRequestStatus.postValue(RequestStatus.ERROR)
                    _scanResultDetails.postValue("Error sending to server: ${e.message}")
                }
            }
        }
    }

    /**
     * Форматирует сообщение об успешном ответе
     */
    private fun formatSuccessMessage(result: ScanResult.Success): String {
        val responseData = JSONObject(result.data)

        val type = result.type
        val message = result.message

        val stringBuilder = StringBuilder()
        stringBuilder.append("Type: ${type.uppercase()}\n\n")
        stringBuilder.append("$message\n\n")

        // Добавляем дополнительные данные, если они есть
        if (responseData.has("serialNumber")) {
            stringBuilder.append("SN: ${responseData.getString("serialNumber")}\n")
        }

        if (responseData.has("created")) {
            val timestamp = responseData.getLong("created")
            val date = java.util.Date(timestamp * 1000L)
            stringBuilder.append("Created: ${date}\n")
        }

        if (responseData.has("class")) {
            stringBuilder.append("Class: ${responseData.getString("class")}\n")
        }

        // Information about images
        if (result.imageUrls.isNotEmpty()) {
            stringBuilder.append("\nImages: ${result.imageUrls.size}\n")
        }

        // Информация о буферах
        try {
            if (responseData.has("buffers")) {
                val buffers = responseData.getJSONObject("buffers")

                val items = buffers.getJSONArray("items")
                val boxes = buffers.getJSONArray("boxes")
                val places = buffers.getJSONArray("places")

                if (items.length() > 0) {
                    stringBuilder.append("\nItems in buffer: ${items.length()}\n")
                    for (i in 0 until items.length()) {
                        stringBuilder.append("- ${items.getString(i)}\n")
                    }
                }

                if (boxes.length() > 0) {
                    stringBuilder.append("\nBoxes in buffer: ${boxes.length()}\n")
                    for (i in 0 until boxes.length()) {
                        stringBuilder.append("- ${boxes.getString(i)}\n")
                    }
                }

                if (places.length() > 0) {
                    stringBuilder.append("\nPlaces in buffer: ${places.length()}\n")
                    for (i in 0 until places.length()) {
                        stringBuilder.append("- ${places.getString(i)}\n")
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing buffers: ${e.message}")
        }

        return stringBuilder.toString()
    }

    override fun onDestroy() {
        super.onDestroy()
        // Отписываемся от обсервера, чтобы избежать утечек памяти
        scannerManager.scanResult.removeObservers(this)
    }
}

/**
 * Статус запроса к серверу
 */
enum class RequestStatus {
    IDLE,      // Нет активного запроса
    LOADING,   // Запрос выполняется
    SUCCESS,   // Успешный ответ
    ERROR      // Ошибка
}

@Composable
fun MainContent(
    scannedBarcode: String?,
    resultDetails: String?,
    requestStatus: RequestStatus?,
    imageUrls: List<String>,
    modifier: Modifier = Modifier,
    onOpenScannerSettings: () -> Unit
) {
    val scrollState = rememberScrollState()

    Column(
        modifier = modifier
            .padding(16.dp)
            .verticalScroll(scrollState),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Заголовок приложения
        Text(
            text = "ECKWMS Scanner",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(bottom = 16.dp)
        )

        // Кнопка для настроек сканера
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Scanner Configuration",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = "Configure scanner settings, test API functions, and view scan images",
                    textAlign = TextAlign.Center,
                    style = MaterialTheme.typography.bodyMedium
                )

                Spacer(modifier = Modifier.height(16.dp))

                Button(
                    onClick = onOpenScannerSettings,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Open Scanner Settings")
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp))
        Divider()
        Spacer(modifier = Modifier.height(16.dp))

        // Отображение деталей результата
        if (resultDetails != null && resultDetails.isNotEmpty()) {
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = "Server Response:",
                        style = MaterialTheme.typography.titleMedium
                    )

                    Spacer(modifier = Modifier.height(8.dp))
                    Divider()
                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = resultDetails,
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }

        // Image viewer section that displays images from the server
        if (imageUrls.isNotEmpty() || requestStatus == RequestStatus.SUCCESS) {
            Spacer(modifier = Modifier.height(16.dp))
            SimpleImageViewerSection(
                imageUrls = imageUrls,
                modifier = Modifier.fillMaxWidth()
            )
        }

        // Spacer to push content to the top
        Spacer(modifier = Modifier.weight(1f))

        // Информация о сервере
        Text(
            text = "Server: https://pda.repair/",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(16.dp))
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ScannerActivity.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ScannerActivity.kt
package com.xelth.eckwms_movfast

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import com.xelth.eckwms_movfast.scanners.ScannerManager
import com.xelth.eckwms_movfast.ui.screens.ScannedImageScreen
import com.xelth.eckwms_movfast.ui.screens.ScannerSettingsScreen
import com.xelth.eckwms_movfast.ui.theme.EckwmsmovFastTheme

class ScannerActivity : ComponentActivity() {
    // Ссылка на ScannerManager
    private lateinit var scannerManager: ScannerManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Получение ScannerManager из приложения
        scannerManager = (application as EckwmsApp).scannerManager

        setContent {
            EckwmsmovFastTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    // Управление навигацией между экранами внутри активности
                    var currentScreen by remember { mutableStateOf("settings") }

                    when (currentScreen) {
                        "settings" -> {
                            ScannerSettingsScreen(
                                scannerManager = scannerManager,
                                onNavigateBack = { finish() },
                                onOpenImageViewer = { currentScreen = "image_viewer" }
                            )
                        }
                        "image_viewer" -> {
                            ScannedImageScreen(
                                scannerManager = scannerManager,
                                onNavigateBack = { currentScreen = "settings" }
                            )
                        }
                    }
                }
            }
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/api/ScanApiService.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/api/ScanApiService.kt
package com.xelth.eckwms_movfast.api

import android.content.Context
import android.provider.Settings
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.OutputStreamWriter
import java.net.HttpURLConnection
import java.net.URL
import java.util.UUID
import com.xelth.eckwms_movfast.scanners.ScannerManager

/**
 * Сервис для взаимодействия с API сканирования штрих-кодов
 */
class ScanApiService(private val context: Context) {
    private val TAG = "ScanApiService"

    // Базовый URL для API
    private val BASE_URL = "https://pda.repair/api/scan"

    // Ссылка на ScannerManager для получения информации о типе штрих-кода
    private var scannerManager: ScannerManager? = null

    // Уникальный идентификатор устройства
    private val deviceId: String by lazy {
        try {
            Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting Android ID: ${e.message}")
            UUID.randomUUID().toString()
        }
    }

    // Установка ScannerManager извне
    fun setScannerManager(manager: ScannerManager) {
        this.scannerManager = manager
    }

    /**
     * Отправляет отсканированный штрих-код на сервер
     * @param barcode Отсканированный штрих-код
     * @return Результат обработки штрих-кода
     */
    suspend fun processScan(barcode: String): ScanResult = withContext(Dispatchers.IO) {
        Log.d(TAG, "Processing scan: $barcode")

        try {
            val url = URL("$BASE_URL/process")
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.setRequestProperty("Accept", "application/json")
            connection.doOutput = true

            // Создаем JSON запрос с barcode и type
            val jsonRequest = JSONObject().apply {
                put("barcode", barcode)

                // Используем ScannerManager для получения типа напрямую, если доступен
                val barcodeType = scannerManager?.getLastBarcodeType() ?: guessType(barcode)

                put("type", barcodeType)
                put("deviceId", deviceId)
            }

            // Отправляем запрос
            val outputStream = connection.outputStream
            val writer = OutputStreamWriter(outputStream, "UTF-8")
            writer.write(jsonRequest.toString())
            writer.flush()
            writer.close()

            // Получаем ответ
            val responseCode = connection.responseCode

            if (responseCode == HttpURLConnection.HTTP_OK) {
                // Читаем успешный ответ
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                val jsonResponse = JSONObject(response)

                if (jsonResponse.has("success") && jsonResponse.getBoolean("success")) {
                    // Existing code to get message and type
                    val message = jsonResponse.optString("text", "Successful scan")
                    val type = jsonResponse.optString("contentType", "unknown")

                    // Parse image URLs from the response
                    val imageUrls = mutableListOf<String>()
                    if (jsonResponse.has("images")) {
                        try {
                            val imagesArray = jsonResponse.getJSONArray("images")
                            for (i in 0 until imagesArray.length()) {
                                imageUrls.add(imagesArray.getString(i))
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "Error parsing image URLs: ${e.message}")
                        }
                    }

                    return@withContext ScanResult.Success(
                        type = type,
                        message = message,
                        data = response,
                        imageUrls = imageUrls
                    )
                } else {
                    return@withContext ScanResult.Error(
                        jsonResponse.optString("text", "Unknown error")
                    )
                }
            } else {
                // Обрабатываем ошибку
                val errorMessage = connection.errorStream?.bufferedReader()?.use { it.readText() }
                    ?: "Error code: $responseCode"

                return@withContext ScanResult.Error(errorMessage)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing scan: ${e.message}", e)
            return@withContext ScanResult.Error(e.message ?: "Unknown error")
        }
    }

    /**
     * Определяет предполагаемый формат штрих-кода
     * Возвращает тип по стандарту GS1 (QR_CODE, DATAMATRIX, CODE_128 и т.д.)
     */
    private fun guessType(barcode: String): String {
        return when {
            // Формат QR кода обычно включает определенные символы и может иметь разную длину
            barcode.contains(":") && barcode.contains("/") -> "QR_CODE"
            // DataMatrix обычно имеет определенную структуру
            barcode.matches(Regex("^[0-9]{4}[A-Z]{2}\\d+$")) -> "DATAMATRIX"
            // Коды EAN/UPC состоят только из цифр и имеют определенную длину
            barcode.length == 13 && barcode.all { it.isDigit() } -> "EAN_13"
            barcode.length == 8 && barcode.all { it.isDigit() } -> "EAN_8"
            barcode.length == 12 && barcode.all { it.isDigit() } -> "UPC_A"
            // CODE_128 может содержать любые символы
            barcode.length > 5 && barcode.any { !it.isLetterOrDigit() } -> "CODE_128"
            // CODE_39 обычно содержит только заглавные буквы, цифры и некоторые символы
            barcode.matches(Regex("^[A-Z0-9 \\-\\.$/+%*]+$")) -> "CODE_39"
            // Для семизначных кодов предметов используем CODE_128
            barcode.length == 7 && barcode.all { it.isDigit() } -> "CODE_128"
            // Для внутренних кодов ECKWMS можно определить формат
            barcode.matches(Regex("^[ibpou][0-9]{18}$")) -> "CODE_128"
            barcode.startsWith("RMA") -> "CODE_128"
            // По умолчанию - неизвестный формат
            else -> "UNKNOWN"
        }
    }
}

/**
 * Класс результата сканирования
 */
sealed class ScanResult {
    /**
     * Успешный результат
     */
    data class Success(
        val type: String,
        val message: String,
        val data: String,
        val imageUrls: List<String> = emptyList() // Added this field for image URLs
    ) : ScanResult()

    /**
     * Ошибка
     */
    data class Error(val message: String) : ScanResult()
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/diagnostics/ScannerApiTester.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/diagnostics/ScannerApiTester.kt
package com.xelth.eckwms_movfast.diagnostics

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.util.Log
import com.tools.XCImage
import com.xcheng.scanner.BarcodeType
import com.xcheng.scanner.FlashMode
import com.xcheng.scanner.AimerMode
import com.xcheng.scanner.OutputMethod
import com.xcheng.scanner.NotificationType
import com.xcheng.scanner.XcBarcodeScanner
import com.xelth.eckwms_movfast.scanners.ScannerManager
import com.xelth.eckwms_movfast.scanners.XCScannerWrapper
import java.lang.reflect.Method
import java.nio.ByteBuffer

/**
 * Stores results of a scanner API test for UI display
 */
data class ScannerApiTestResult(
    val name: String,
    val success: Boolean,
    val functionResults: List<FunctionTestResult>
)

/**
 * Represents the result of testing a single scanner function
 */
data class FunctionTestResult(
    val functionName: String,
    val passed: Boolean,
    val message: String = ""
)

/**
 * Класс для тестирования и вывода информации о доступных API функциях сканера
 * в журнал Logcat для диагностики и отладки.
 */
class ScannerApiTester(private val scannerManager: ScannerManager) {
    private val TAG = "ScannerApiTester"

    /**
     * Метод для преобразования 8-битных необработанных данных в Bitmap
     * как в Java-примере
     */
    private fun raw8ToBitmap(data: ByteArray, width: Int, height: Int): Bitmap? {
        try {
            val bits = ByteArray(data.size * 4) // RGBA массив

            for (i in data.indices) {
                // Оригинальный принцип: 4 байта представляют один пиксель, RGB = значение яркости, Alpha = 0xFF
                bits[i * 4 + 0] = data[i] // R
                bits[i * 4 + 1] = data[i] // G
                bits[i * 4 + 2] = data[i] // B
                bits[i * 4 + 3] = -1      // 0xFF, A
            }

            // Bitmap.Config.ARGB_8888 означает: режим изображения 8 бит
            val bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            bmp.copyPixelsFromBuffer(ByteBuffer.wrap(bits))

            return bmp
        } catch (e: Exception) {
            Log.e(TAG, "Error converting raw8 to bitmap: ${e.message}")
            return null
        }
    }

    /**
     * Запускает проверку всех API функций сканера и выводит результаты в Logcat
     */
    fun testAndLogAllApiFunctions() {
        Log.d(TAG, "===== НАЧАЛО ТЕСТИРОВАНИЯ API СКАНЕРА =====")
        Log.d(TAG, "")

        // Информация о состоянии сканера
        testScannerStatus()
        Log.d(TAG, "")

        // Проверка поддержки типов штрих-кодов
        testBarcodeTypes()
        Log.d(TAG, "")

        // Тестирование функций изображения
        testImageFunctions()
        Log.d(TAG, "")

        // Тестирование доступных методов в SDK
        testAvailableMethods()
        Log.d(TAG, "")

        // Тестирование настроек сканера
        testScannerSettings()
        Log.d(TAG, "")

        Log.d(TAG, "===== ЗАВЕРШЕНИЕ ТЕСТИРОВАНИЯ API СКАНЕРА =====")
    }

    /**
     * Проверяет и выводит информацию о состоянии сканера
     */
    private fun testScannerStatus() {
        Log.d(TAG, "СОСТОЯНИЕ СКАНЕРА:")

        try {
            val isInitialized = scannerManager.isInitialized()
            Log.d(TAG, "✓ Инициализирован: $isInitialized")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Ошибка проверки инициализации: ${e.message}")
        }

        try {
            val lastBarcode = scannerManager.scanResult.value
            Log.d(TAG, "✓ Последний штрих-код: ${lastBarcode ?: "нет"}")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Ошибка получения последнего штрих-кода: ${e.message}")
        }

        try {
            val isLoopScanActive = scannerManager.isLoopScanRunning()
            Log.d(TAG, "✓ Непрерывное сканирование активно: $isLoopScanActive")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Ошибка проверки непрерывного сканирования: ${e.message}")
        }

        try {
            val version = XCScannerWrapper.getServiceVersion()
            Log.d(TAG, "✓ Версия сервиса сканирования: $version")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Ошибка получения версии сервиса: ${e.message}")
        }
    }

    /**
     * Проверяет поддержку различных типов штрих-кодов
     */
    private fun testBarcodeTypes() {
        Log.d(TAG, "ПОДДЕРЖКА ТИПОВ ШТРИХ-КОДОВ:")

        val barcodeTypes = listOf(
            "QRCODE" to BarcodeType.QRCODE,
            "CODE128" to BarcodeType.CODE128,
            "CODE39" to BarcodeType.CODE39,
            "EAN13" to BarcodeType.EAN13,
            "EAN8" to BarcodeType.EAN8,
            "UPCA" to BarcodeType.UPCA,
            "UPCE" to BarcodeType.UPCE,
            "DATAMATRIX" to BarcodeType.DATAMATRIX,
            "PDF417" to BarcodeType.PDF417
        )

        barcodeTypes.forEach { (name, type) ->
            try {
                val isEnabled = XCScannerWrapper.isBarcodeTypeEnabled(type)
                Log.d(TAG, "✓ $name: ${if (isEnabled) "включен" else "выключен"}")
            } catch (e: Exception) {
                Log.e(TAG, "✗ $name: ошибка проверки: ${e.message}")
            }
        }
    }

    /**
     * Тестирует функции, связанные с изображениями, используя непосредственно XcBarcodeScanner
     * как в Java-примере
     */
    private fun testImageFunctions() {
        Log.d(TAG, "ФУНКЦИИ ИЗОБРАЖЕНИЯ:")

        try {
            Log.d(TAG, "Пытаемся получить последнее декодированное изображение...")
            val lastImg = XcBarcodeScanner.getLastDecodeImage()

            if (lastImg != null) {
                Log.d(TAG, "✓ Изображение получено успешно!")

                // Получаем данные как в Java-примере
                val width = lastImg.width
                val height = lastImg.height
                val stride = lastImg.stride
                val data = lastImg.data

                Log.d(TAG, "  - Размер: ${width}x${height}, stride: $stride")

                if (data != null) {
                    Log.d(TAG, "  - Данные: размер=${data.size} байт")

                    // Пробуем преобразовать в bitmap как в Java-примере
                    val bitmap = raw8ToBitmap(data, width, height)

                    if (bitmap != null) {
                        Log.d(TAG, "  - Успешно преобразовано в Bitmap размером ${bitmap.width}x${bitmap.height}")
                    } else {
                        Log.d(TAG, "  - Не удалось преобразовать в Bitmap")
                    }
                } else {
                    Log.d(TAG, "  - Данные: null")
                }
            } else {
                Log.d(TAG, "✗ getLastDecodeImage вернул null")
            }
        } catch (e: Exception) {
            Log.e(TAG, "✗ Ошибка при вызове getLastDecodeImage: ${e.message}")
            e.printStackTrace()
        }
    }

    /**
     * Проверяет доступные методы в SDK сканера через рефлексию
     */
    private fun testAvailableMethods() {
        Log.d(TAG, "ДОСТУПНЫЕ МЕТОДЫ:")

        // Проверяем методы в XCScannerWrapper
        val scannerWrapperMethods = XCScannerWrapper::class.java.declaredMethods
        Log.d(TAG, "Методы в XCScannerWrapper (${scannerWrapperMethods.size}):")
        scannerWrapperMethods.distinctBy { it.name }.sortedBy { it.name }.forEach { method ->
            Log.d(TAG, "  - ${method.name}(${method.parameterTypes.joinToString(", ") { it.simpleName }})")
        }

        // Проверяем публичные методы в XcBarcodeScanner
        val scannerSdkMethods = XcBarcodeScanner::class.java.methods
        Log.d(TAG, "Публичные методы в XcBarcodeScanner (${scannerSdkMethods.size}):")
        scannerSdkMethods.distinctBy { it.name }.sortedBy { it.name }.forEach { method ->
            Log.d(TAG, "  - ${method.name}(${method.parameterTypes.joinToString(", ") { it.simpleName }})")
        }

        // Проверяем методы XCImage если возможно
        try {
            val xcImageMethods = XCImage::class.java.methods
            Log.d(TAG, "Методы в XCImage (${xcImageMethods.size}):")
            xcImageMethods.distinctBy { it.name }.sortedBy { it.name }.forEach { method ->
                Log.d(TAG, "  - ${method.name}(${method.parameterTypes.joinToString(", ") { it.simpleName }})")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка получения методов XCImage: ${e.message}")
        }
    }

    /**
     * Тестирует настройки сканера
     */
    private fun testScannerSettings() {
        Log.d(TAG, "НАСТРОЙКИ СКАНЕРА:")

        // Тестирование режимов работы вспышки
        testScannerSetting(
            "Flash Modes",
            listOf(
                "OFF" to FlashMode.OFF,
                "ILLUME_ONLY" to FlashMode.ILLUME_ONLY,
                "ILLUME_STROBE" to FlashMode.ILLUME_STROBE
            ),
            XCScannerWrapper::setFlashLightsMode
        )

        // Тестирование режимов работы прицела
        testScannerSetting(
            "Aimer Modes",
            listOf(
                "ALWAYS_OFF" to AimerMode.ALWAYS_OFF,
                "TRIGGER_ON" to AimerMode.TRIGGER_ON,
                "ALWAYS_ON" to AimerMode.ALWAYS_ON
            ),
            XCScannerWrapper::setAimerLightsMode
        )

        // Тестирование методов вывода (только доступные константы)
        testScannerSetting(
            "Output Methods",
            listOf(
                "BROADCAST_EVENT" to OutputMethod.BROADCAST,
                "CLIPBOARD" to OutputMethod.CLIPBOARD
                // Убраны недоступные константы FILL_FORM и KEY_EVENT
            ),
            XCScannerWrapper::setOutputMethod
        )

        // Тестирование типов уведомлений (только доступные константы)
        testScannerSetting(
            "Notification Types",
            listOf(
                // Убрана недоступная константа NONE
                "SOUND" to NotificationType.SOUND,
                "SOUND_VIBRATOR" to NotificationType.SOUND_VIBRATOR,
                "VIBRATOR" to NotificationType.VIBRATOR
            ),
            XCScannerWrapper::setSuccessNotification
        )
    }

    /**
     * Общий метод для тестирования настроек сканера
     */
    private fun <T> testScannerSetting(
        settingName: String,
        options: List<Pair<String, T>>,
        setterMethod: (T) -> Unit
    ) {
        Log.d(TAG, "$settingName:")

        options.forEach { (name, value) ->
            try {
                setterMethod(value)
                Log.d(TAG, "  ✓ $name: установлено успешно")
            } catch (e: Exception) {
                Log.e(TAG, "  ✗ $name: ошибка установки: ${e.message}")
            }
        }
    }

    /**
     * Runs all API tests and returns results in a UI-friendly format
     * @return Test results for UI display
     */
    fun runUIFriendlyTests(): ScannerApiTestResult {
        val results = mutableListOf<FunctionTestResult>()

        // Test scanner status
        results.addAll(testScannerStatusUI())

        // Test barcode types
        results.addAll(testBarcodeTypesUI())

        // Test scanner settings
        results.addAll(testScannerSettingsUI())

        // Test image functions
        results.addAll(testImageFunctionsUI())

        val allPassed = results.all { it.passed }

        return ScannerApiTestResult(
            name = "All Tests",
            success = allPassed,
            functionResults = results
        )
    }

    /**
     * Tests basic scanner status and returns results for UI display
     * @return List of test results
     */
    fun testScannerStatusUI(): List<FunctionTestResult> {
        val results = mutableListOf<FunctionTestResult>()

        try {
            // Test initialization
            val isInitialized = scannerManager.isInitialized()
            results.add(
                FunctionTestResult(
                    functionName = "Scanner Initialization",
                    passed = isInitialized,
                    message = if (isInitialized) "Scanner is initialized" else "Scanner is not initialized"
                )
            )
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Scanner Initialization",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        try {
            // Test version retrieval
            val version = XCScannerWrapper.getServiceVersion()
            results.add(
                FunctionTestResult(
                    functionName = "Service Version",
                    passed = version.isNotEmpty(),
                    message = if (version.isNotEmpty()) "Version: $version" else "Failed to get version"
                )
            )
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Service Version",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        try {
            // Test loop scan status
            val isLoopScanActive = scannerManager.isLoopScanRunning()
            results.add(
                FunctionTestResult(
                    functionName = "Loop Scan Status",
                    passed = true, // This is just a status check, not a pass/fail test
                    message = if (isLoopScanActive) "Loop scanning is active" else "Loop scanning is not active"
                )
            )
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Loop Scan Status",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        return results
    }

    /**
     * Tests barcode type support and returns results for UI display
     * @return List of test results
     */
    fun testBarcodeTypesUI(): List<FunctionTestResult> {
        val results = mutableListOf<FunctionTestResult>()

        val barcodeTypes = listOf(
            "QR Code" to BarcodeType.QRCODE,
            "Code 128" to BarcodeType.CODE128,
            "Code 39" to BarcodeType.CODE39,
            "EAN-13" to BarcodeType.EAN13,
            "EAN-8" to BarcodeType.EAN8,
            "UPC-A" to BarcodeType.UPCA,
            "UPC-E" to BarcodeType.UPCE,
            "DataMatrix" to BarcodeType.DATAMATRIX,
            "PDF417" to BarcodeType.PDF417
        )

        var overallSuccess = true

        for ((name, type) in barcodeTypes) {
            try {
                // Test if the barcode type is enabled
                val wasEnabled = XCScannerWrapper.isBarcodeTypeEnabled(type)

                // Try to toggle the state
                XCScannerWrapper.enableBarcodeType(type, !wasEnabled)
                val toggledState = XCScannerWrapper.isBarcodeTypeEnabled(type)
                val toggleSuccess = toggledState != wasEnabled

                // Restore original state
                XCScannerWrapper.enableBarcodeType(type, wasEnabled)
                val restoredState = XCScannerWrapper.isBarcodeTypeEnabled(type)
                val restoreSuccess = restoredState == wasEnabled

                val success = toggleSuccess && restoreSuccess
                overallSuccess = overallSuccess && success

                results.add(
                    FunctionTestResult(
                        functionName = "$name Barcode Support",
                        passed = success,
                        message = if (success)
                            "Successfully toggled state"
                        else
                            "Failed to toggle barcode state"
                    )
                )
            } catch (e: Exception) {
                overallSuccess = false
                results.add(
                    FunctionTestResult(
                        functionName = "$name Barcode Support",
                        passed = false,
                        message = "Error: ${e.message}"
                    )
                )
            }
        }

        results.add(0,
            FunctionTestResult(
                functionName = "Barcode Types Support",
                passed = overallSuccess,
                message = if (overallSuccess)
                    "All barcode types supported"
                else
                    "Some barcode types not supported"
            )
        )

        return results
    }

    /**
     * Tests scanner settings and returns results for UI display
     * @return List of test results
     */
    fun testScannerSettingsUI(): List<FunctionTestResult> {
        val results = mutableListOf<FunctionTestResult>()

        // Test flash modes
        try {
            val flashModeResults = testSettingOptionUI(
                "Flash Mode",
                listOf(
                    "Off" to FlashMode.OFF,
                    "Illuminate Only" to FlashMode.ILLUME_ONLY,
                    "Illuminate with Strobe" to FlashMode.ILLUME_STROBE
                ),
                XCScannerWrapper::setFlashLightsMode
            )
            results.addAll(flashModeResults)
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Flash Modes",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        // Test aimer modes
        try {
            val aimerModeResults = testSettingOptionUI(
                "Aimer Mode",
                listOf(
                    "Always Off" to AimerMode.ALWAYS_OFF,
                    "On During Scan" to AimerMode.TRIGGER_ON,
                    "Always On" to AimerMode.ALWAYS_ON
                ),
                XCScannerWrapper::setAimerLightsMode
            )
            results.addAll(aimerModeResults)
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Aimer Modes",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        // Test output methods
        try {
            val outputMethodResults = testSettingOptionUI(
                "Output Method",
                listOf(
                    "Broadcast" to OutputMethod.BROADCAST,
                    "Clipboard" to OutputMethod.CLIPBOARD
                ),
                XCScannerWrapper::setOutputMethod
            )
            results.addAll(outputMethodResults)
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Output Methods",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        // Test notification types
        try {
            val notificationResults = testSettingOptionUI(
                "Notification Type",
                listOf(
                    "Sound" to NotificationType.SOUND,
                    "Sound and Vibration" to NotificationType.SOUND_VIBRATOR,
                    "Vibration" to NotificationType.VIBRATOR
                ),
                XCScannerWrapper::setSuccessNotification
            )
            results.addAll(notificationResults)
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Notification Types",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        // Test timeout setting
        try {
            val minTimeout = 1
            val maxTimeout = 9

            // Try setting min value
            XCScannerWrapper.setTimeout(minTimeout)

            // Try setting max value
            XCScannerWrapper.setTimeout(maxTimeout)

            results.add(
                FunctionTestResult(
                    functionName = "Timeout Setting",
                    passed = true,
                    message = "Successfully set timeout values"
                )
            )
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Timeout Setting",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        return results
    }

    /**
     * Tests image functions and returns results for UI display
     * Использует правильный подход из Java-примера для доступа к изображениям
     * @return List of test results
     */
    fun testImageFunctionsUI(): List<FunctionTestResult> {
        val results = mutableListOf<FunctionTestResult>()

        // Test getLastDecodeImage
        try {
            // Используем метод через XCScannerWrapper
            val lastImg = XCScannerWrapper.getLastDecodeImage()
            val hasImage = lastImg != null

            if (hasImage) {
                val width = lastImg?.width ?: 0
                val height = lastImg?.height ?: 0
                val stride = lastImg?.stride ?: 0
                val hasData = lastImg?.data != null
                val dataSize = lastImg?.data?.size ?: 0

                results.add(
                    FunctionTestResult(
                        functionName = "Image Retrieval",
                        passed = true,
                        message = "Got image: ${width}x${height}, stride: $stride, data size: $dataSize bytes"
                    )
                )

                // Test image conversion to bitmap
                if (hasData) {
                    try {
                        val data = lastImg?.data
                        if (data != null) {
                            val bitmap = raw8ToBitmap(data, width, height)
                            val bitmapCreated = bitmap != null

                            results.add(
                                FunctionTestResult(
                                    functionName = "Bitmap Conversion",
                                    passed = bitmapCreated,
                                    message = if (bitmapCreated)
                                        "Successfully converted to bitmap ${bitmap?.width}x${bitmap?.height}"
                                    else
                                        "Failed to convert to bitmap"
                                )
                            )
                        }
                    } catch (e: Exception) {
                        results.add(
                            FunctionTestResult(
                                functionName = "Bitmap Conversion",
                                passed = false,
                                message = "Error: ${e.message}"
                            )
                        )
                    }
                } else {
                    results.add(
                        FunctionTestResult(
                            functionName = "Image Data",
                            passed = false,
                            message = "No image data available"
                        )
                    )
                }
            } else {
                results.add(
                    FunctionTestResult(
                        functionName = "Image Retrieval",
                        passed = false,
                        message = "No image available - try scanning first"
                    )
                )
            }
        } catch (e: Exception) {
            results.add(
                FunctionTestResult(
                    functionName = "Image Retrieval",
                    passed = false,
                    message = "Error: ${e.message}"
                )
            )
        }

        return results
    }

    /**
     * Generic helper to test setting options
     */
    private fun <T> testSettingOptionUI(
        settingName: String,
        options: List<Pair<String, T>>,
        setterMethod: (T) -> Unit
    ): List<FunctionTestResult> {
        val results = mutableListOf<FunctionTestResult>()

        var allOptionsPassed = true

        for ((name, value) in options) {
            try {
                setterMethod(value)
                results.add(
                    FunctionTestResult(
                        functionName = "$settingName: $name",
                        passed = true,
                        message = "Successfully set option"
                    )
                )
            } catch (e: Exception) {
                allOptionsPassed = false
                results.add(
                    FunctionTestResult(
                        functionName = "$settingName: $name",
                        passed = false,
                        message = "Error: ${e.message}"
                    )
                )
            }
        }

        results.add(0,
            FunctionTestResult(
                functionName = "$settingName Support",
                passed = allOptionsPassed,
                message = if (allOptionsPassed)
                    "All $settingName options supported"
                else
                    "Some $settingName options not supported"
            )
        )

        return results
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/diagnostics/ScannerImageDiagnostics.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/diagnostics/ScannerImageDiagnostics.kt
package com.xelth.eckwms_movfast.diagnostics

import android.util.Log
import com.tools.XCImage
import com.xcheng.scanner.XcBarcodeScanner
import java.lang.reflect.Field
import java.lang.reflect.Method

/**
 * Класс для глубокой диагностики функций изображения в API сканера
 */
class ScannerImageDiagnostics {
    private val TAG = "ScannerImageDiagnostics"

    /**
     * Запускает полную диагностику функций изображения сканера
     */
    fun runFullDiagnostics() {
        Log.d(TAG, "===== НАЧАЛО ГЛУБОКОЙ ДИАГНОСТИКИ ФУНКЦИЙ ИЗОБРАЖЕНИЯ СКАНЕРА =====")

        // Проверка внутреннего состояния сканера через рефлексию
        checkScannerInternalState()

        // Проверка метода getLastDecodeImage
        checkLastDecodeImageMethod()

        // Проверка структуры класса XCImage
        checkXCImageStructure()

        Log.d(TAG, "===== ЗАВЕРШЕНИЕ ГЛУБОКОЙ ДИАГНОСТИКИ ФУНКЦИЙ ИЗОБРАЖЕНИЯ СКАНЕРА =====")
    }

    /**
     * Проверяет внутреннее состояние сканера через рефлексию
     */
    private fun checkScannerInternalState() {
        Log.d(TAG, "--- Проверка внутреннего состояния сканера ---")

        try {
            // Получаем поля через рефлексию
            val fields = XcBarcodeScanner::class.java.declaredFields

            Log.d(TAG, "Поля XcBarcodeScanner:")
            for (field in fields) {
                field.isAccessible = true
                try {
                    Log.d(TAG, "  - ${field.name}: ${getFieldValue(field)}")

                    // Если это поле IScanner, проверим его подробнее
                    if (field.name.contains("Scanner", ignoreCase = true) ||
                        field.type.name.contains("IScanner", ignoreCase = true)) {
                        val scannerObj = field.get(null)
                        if (scannerObj == null) {
                            Log.d(TAG, "    • IScanner объект: NULL")
                        } else {
                            Log.d(TAG, "    • IScanner объект: ${scannerObj.javaClass.name}")

                            // Проверяем методы этого объекта
                            val methods = scannerObj.javaClass.methods
                            Log.d(TAG, "    • Доступные методы:")
                            for (method in methods) {
                                Log.d(TAG, "      - ${method.name}()")
                            }
                        }
                    }
                } catch (e: Exception) {
                    Log.d(TAG, "  - ${field.name}: Ошибка доступа - ${e.message}")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка при проверке внутреннего состояния сканера: ${e.message}")
            e.printStackTrace()
        }
    }

    /**
     * Получает значение поля для вывода в лог
     */
    private fun getFieldValue(field: Field): String {
        try {
            val value = field.get(null)
            return when {
                value == null -> "null"
                value is String -> "\"$value\""
                value is Number -> value.toString()
                value is Boolean -> value.toString()
                else -> "${value.javaClass.simpleName}@${System.identityHashCode(value)}"
            }
        } catch (e: Exception) {
            return "Error: ${e.message}"
        }
    }

    /**
     * Проверяет метод getLastDecodeImage
     */
    private fun checkLastDecodeImageMethod() {
        Log.d(TAG, "--- Проверка метода getLastDecodeImage ---")

        try {
            // Проверяем через рефлексию
            val method = XcBarcodeScanner::class.java.getDeclaredMethod("getLastDecodeImage")
            Log.d(TAG, "Метод getLastDecodeImage найден:")
            Log.d(TAG, "  - Возвращаемый тип: ${method.returnType.name}")
            Log.d(TAG, "  - Модификаторы: ${method.modifiers}")

            // Пробуем вызвать метод напрямую через рефлексию
            Log.d(TAG, "Пытаемся вызвать метод напрямую...")
            try {
                val image = XcBarcodeScanner.getLastDecodeImage()
                if (image == null) {
                    Log.d(TAG, "  - Результат: null")
                } else {
                    Log.d(TAG, "  - Результат: XCImage объект получен!")
                    Log.d(TAG, "  - Размер: ${image.width}x${image.height}")
                    val data = image.data
                    Log.d(TAG, "  - Данные: ${data?.javaClass?.name ?: "null"}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "  - Ошибка при вызове метода: ${e.message}")
                e.printStackTrace()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка при проверке метода getLastDecodeImage: ${e.message}")
            e.printStackTrace()
        }
    }

    /**
     * Проверяет структуру класса XCImage
     */
    private fun checkXCImageStructure() {
        Log.d(TAG, "--- Проверка структуры класса XCImage ---")

        try {
            val fields = XCImage::class.java.declaredFields

            Log.d(TAG, "Поля XCImage:")
            for (field in fields) {
                field.isAccessible = true
                Log.d(TAG, "  - ${field.name}: ${field.type.name}")
            }

            val methods = XCImage::class.java.declaredMethods

            Log.d(TAG, "Методы XCImage:")
            for (method in methods) {
                Log.d(TAG, "  - ${method.name}(${method.parameterTypes.joinToString(", ") { it.simpleName }}): ${method.returnType.simpleName}")
            }

            // Проверяем реализацию Parcelable
            val parcelableFields = XCImage::class.java.getFields()
                .filter { it.name == "CREATOR" }

            if (parcelableFields.isNotEmpty()) {
                Log.d(TAG, "  - Класс реализует Parcelable (CREATOR найден)")
            } else {
                Log.d(TAG, "  - Класс НЕ реализует Parcelable или CREATOR не доступен")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка при проверке структуры класса XCImage: ${e.message}")
            e.printStackTrace()
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/scanners/ScannerManager.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/scanners/ScannerManager.kt
package com.xelth.eckwms_movfast.scanners

import android.app.Application
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.xcheng.scanner.BarcodeType
import com.xcheng.scanner.NotificationType
import com.xcheng.scanner.OutputMethod
import com.xcheng.scanner.RegionSizeType
import com.xcheng.scanner.TextCaseType

// Константы для broadcast
private const val SCAN_ACTION = "com.xcheng.scanner.action.BARCODE_DECODING_BROADCAST"
private const val SCAN_DATA_KEY = "EXTRA_BARCODE_DECODING_DATA"
private const val TAG = "ScannerManager"




/**
 * Синглтон для управления сканером на уровне приложения
 */
class ScannerManager private constructor(private val application: Application) {
    // LiveData для передачи результатов сканирования
    private val _scanResult = MutableLiveData<String>()
    val scanResult: LiveData<String> get() = _scanResult

    // BroadcastReceiver для получения результатов сканирования
    private var scanReceiver: BroadcastReceiver? = null

    // Флаг для отслеживания состояния инициализации
    private var isInitialized = false

    // Обработчик главного потока
    private val mainHandler = Handler(Looper.getMainLooper())

    /**
     * Инициализирует сканер и BroadcastReceiver
     */
    fun initialize() {
        if (isInitialized) {
            Log.d(TAG, "Сканер уже инициализирован")
            return
        }

        Log.d(TAG, "⭐ Инициализация сканера на уровне приложения...")

        // Инициализация XCScannerWrapper
        XCScannerWrapper.initialize(application) { result ->
            Log.d(TAG, "⭐ Scan result received via SDK callback: $result")
            _scanResult.postValue(result)
        }

        // Настройка сканера
        configureScanner()

        // Регистрация BroadcastReceiver для получения результатов сканирования
        registerBroadcastReceiver()

        isInitialized = true
        Log.d(TAG, "✓ Сканер успешно инициализирован")
    }

    /**
     * Регистрирует BroadcastReceiver для получения результатов сканирования
     */
    private fun registerBroadcastReceiver() {
        // Отменяем предыдущую регистрацию, если есть
        unregisterBroadcastReceiver()

        // Создаем новый BroadcastReceiver
        scanReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                Log.d(TAG, "⭐ BroadcastReceiver получил Intent: ${intent.action}")

                // Проверяем, что это именно наш action
                if (intent.action == SCAN_ACTION) {
                    val barcode = intent.getStringExtra(SCAN_DATA_KEY)

                    if (barcode != null) {
                        Log.d(TAG, "⭐⭐⭐ Получен штрих-код через broadcast: $barcode")

                        // Check if this is a duplicate of what we've already processed through the callback
                        if (barcode == _scanResult.value) {
                            Log.d(TAG, "Ignoring duplicate barcode from broadcast - already processed via callback")
                            return
                        }

                        // Отправляем результат через LiveData
                        _scanResult.postValue(barcode)
                    } else {
                        Log.d(TAG, "⚠️ Intent не содержит данных по ключу $SCAN_DATA_KEY")
                        // Проверяем все extras для отладки
                        intent.extras?.keySet()?.forEach { key ->
                            Log.d(TAG, "  Ключ: $key, Значение: ${intent.extras?.get(key)}")
                        }
                    }
                }
            }
        }

        // Регистрируем BroadcastReceiver с правильными флагами для Android 13+
        val intentFilter = IntentFilter(SCAN_ACTION)

        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            application.registerReceiver(scanReceiver, intentFilter, Context.RECEIVER_NOT_EXPORTED)
            Log.d(TAG, "✓ BroadcastReceiver зарегистрирован с флагом RECEIVER_NOT_EXPORTED")
        } else {
            application.registerReceiver(scanReceiver, intentFilter)
            Log.d(TAG, "✓ BroadcastReceiver зарегистрирован")
        }
    }

    /**
     * Отменяет регистрацию BroadcastReceiver
     */
    private fun unregisterBroadcastReceiver() {
        scanReceiver?.let {
            try {
                application.unregisterReceiver(it)
                Log.d(TAG, "✓ BroadcastReceiver отменен")
            } catch (e: Exception) {
                Log.e(TAG, "Ошибка при отмене регистрации BroadcastReceiver", e)
            }
            scanReceiver = null
        }
    }

    // Add this method directly to ScannerManager.kt class
    // rather than using an extension function

    /**
     * Возвращает тип последнего отсканированного штрихкода
     * @return Строковое обозначение типа штрихкода (QR_CODE, DATAMATRIX, CODE_128, etc.)
     */
    fun getLastBarcodeType(): String {
        // Get barcode type from scanner library if available
        // The XcBarcodeScanner does not provide direct access to barcode type information
        // so we'll use context clues from the barcode itself to determine the type

        val lastBarcode = scanResult.value ?: return "UNKNOWN"

        return when {
            // QR Code typical patterns
            lastBarcode.contains(":") && lastBarcode.contains("/") -> "QR_CODE"

            // DataMatrix typical patterns (often used for small items or components)
            lastBarcode.matches(Regex("^[0-9]{4}[A-Z]{2}\\d+$")) -> "DATAMATRIX"

            // EAN/UPC codes are pure digits with specific lengths
            lastBarcode.length == 13 && lastBarcode.all { it.isDigit() } -> "EAN_13"
            lastBarcode.length == 8 && lastBarcode.all { it.isDigit() } -> "EAN_8"
            lastBarcode.length == 12 && lastBarcode.all { it.isDigit() } -> "UPC_A"

            // ECKWMS internal codes likely use CODE_128
            lastBarcode.matches(Regex("^[ibpou][0-9]{18}$")) -> "CODE_128"
            lastBarcode.length == 7 && lastBarcode.all { it.isDigit() } -> "CODE_128"
            lastBarcode.startsWith("RMA") -> "CODE_128"

            // CODE_39 usually contains only uppercase letters, digits and some symbols
            lastBarcode.matches(Regex("^[A-Z0-9 \\-\\.$/+%*]+$")) -> "CODE_39"

            // If no specific pattern matched, but has special characters, assume CODE_128
            lastBarcode.any { !it.isLetterOrDigit() } -> "CODE_128"

            // Default fallback
            else -> "UNKNOWN"
        }
    }

    /**
     * Настраивает сканер с оптимальными параметрами
     */
    private fun configureScanner() {
        Log.d(TAG, "⭐ Настройка сканера...")

        // Настройка вывода для работы с broadcast
        XCScannerWrapper.setOutputMethod(OutputMethod.BROADCAST)

        // Максимальная область сканирования
        XCScannerWrapper.setScanRegionSize(RegionSizeType.VIEWSIZE_100)

        // Максимальное время сканирования
        XCScannerWrapper.setTimeout(9)

        // Звуковое и вибро-оповещение при успешном сканировании
        XCScannerWrapper.setSuccessNotification(NotificationType.SOUND_VIBRATOR)

        // Включить LED-индикатор при успешном сканировании
        XCScannerWrapper.enableSuccessIndicator(true)

        // Настройка обработки текста
        XCScannerWrapper.setTextCase(TextCaseType.NONE)

        // Включить распознавание всех основных типов штрих-кодов
        XCScannerWrapper.enableBarcodeType(BarcodeType.QRCODE, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.CODE128, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.CODE39, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.EAN13, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.EAN8, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.UPCA, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.UPCE, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.DATAMATRIX, true)
        XCScannerWrapper.enableBarcodeType(BarcodeType.PDF417, true)

        Log.d(TAG, "✓ Сканер настроен с оптимальными параметрами")
    }

    /**
     * Останавливает сканирование и освобождает ресурсы сканера при завершении работы приложения
     */
    fun cleanup() {
        if (!isInitialized) return

        // Останавливаем сканирование
        XCScannerWrapper.stopScan()
        if (XCScannerWrapper.isLoopScanRunning()) {
            XCScannerWrapper.stopLoopScan()
        }

        // Очистка ресурсов изображений
        cleanupImageResources()

        // Отменяем регистрацию BroadcastReceiver
        unregisterBroadcastReceiver()

        // Деинициализируем сканер
        XCScannerWrapper.deinitialize(application)

        isInitialized = false
        Log.d(TAG, "✓ Ресурсы сканера освобождены")
    }



    /**
     * Проверяет, инициализирован ли сканер
     * @return true если сканер инициализирован, false в противном случае
     */
    fun isInitialized(): Boolean {
        return isInitialized
    }

    /**
     * Включает/выключает определенный тип штрих-кода
     */
    fun enableBarcodeType(barcodeType: String, enabled: Boolean) {
        if (!isInitialized) initialize()
        XCScannerWrapper.enableBarcodeType(barcodeType, enabled)
    }

    /**
     * Запускает сканирование
     */
    fun startScan() {
        if (!isInitialized) initialize()
        XCScannerWrapper.startScan()
    }

    /**
     * Останавливает сканирование
     */
    fun stopScan() {
        if (!isInitialized) return
        XCScannerWrapper.stopScan()
    }

    /**
     * Запускает непрерывное сканирование
     */
    fun startLoopScan(intervalMs: Int = 500) {
        if (!isInitialized) initialize()
        XCScannerWrapper.setLoopScanInterval(intervalMs)
        XCScannerWrapper.startLoopScan()
    }

    /**
     * Останавливает непрерывное сканирование
     */
    fun stopLoopScan() {
        if (!isInitialized) return
        XCScannerWrapper.stopLoopScan()
    }

    /**
     * Устанавливает режим подсветки
     */
    fun setFlashLightsMode(flashMode: Int) {
        if (!isInitialized) initialize()
        XCScannerWrapper.setFlashLightsMode(flashMode)
    }

    /**
     * Устанавливает режим прицела
     */
    fun setAimerLightsMode(aimerMode: Int) {
        if (!isInitialized) initialize()
        XCScannerWrapper.setAimerLightsMode(aimerMode)
    }

    /**
     * Checks if the device's scanner hardware supports image capture
     * @return true if image capture is supported, false otherwise
     */
    fun isImageCaptureSupported(): Boolean {
        if (!isInitialized()) {
            Log.d(TAG, "Scanner not initialized - cannot check image support")
            return false
        }
        return XCScannerWrapper.isImageCaptureSupported()
    }


    /**
     * Проверяет, запущено ли непрерывное сканирование
     */
    fun isLoopScanRunning(): Boolean {
        return isInitialized && XCScannerWrapper.isLoopScanRunning()
    }

    companion object {
        @Volatile
        private var instance: ScannerManager? = null

        fun getInstance(application: Application): ScannerManager {
            return instance ?: synchronized(this) {
                instance ?: ScannerManager(application).also { instance = it }
            }
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/scanners/ScannerManagerImageExtensions.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/scanners/ScannerManagerImageExtensions.kt
package com.xelth.eckwms_movfast.scanners

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.Rect
import android.graphics.Typeface
import android.util.Log
import com.tools.XCImage
import com.xcheng.scanner.XcBarcodeScanner
import java.nio.ByteBuffer

/**
 * Расширение ScannerManager для работы с изображениями штрих-кодов
 */

private const val TAG = "ScannerManagerImage"

/**
 * Обработчик ошибок API изображений
 * @param errorMessage Текст ошибки для логирования
 * @param exception Исключение, которое произошло (если есть)
 * @param barcodeValue Значение отсканированного штрих-кода (если есть)
 * @return Созданное мок-изображение или null
 */
private fun handleImageError(errorMessage: String, exception: Exception? = null, barcodeValue: String? = null): Bitmap? {
    if (exception != null) {
        Log.e(TAG, errorMessage, exception)
    } else {
        Log.e(TAG, errorMessage)
    }

    // Создаем мок-изображение, если доступен штрих-код
    return if (!barcodeValue.isNullOrEmpty()) {
        Log.d(TAG, "Creating mock barcode image after error: $barcodeValue")
        createMockBarcodeImage(barcodeValue)
    } else {
        null
    }
}

/**
 * Получает последнее декодированное изображение из сканера или создает мок-изображение,
 * если изображение из сканера недоступно
 * @return Bitmap или null, если изображение недоступно
 */
fun ScannerManager.getLastDecodedImage(): Bitmap? {
    if (!this.isInitialized()) {
        return handleImageError("Scanner not initialized")
    }

    // Получаем текущий штрих-код для резервного решения
    val lastBarcode = scanResult.value

    try {
        Log.d(TAG, "Getting last decoded image from scanner")

        // Проверяем состояние сервиса сканера
        if (XcBarcodeScanner.a == null) {
            Log.d(TAG, "Scanner service reference is null - cannot get image")
            return handleImageError("Scanner service unavailable", barcodeValue = lastBarcode)
        }

        // Проверяем, поддерживает ли устройство захват изображений
        if (!XCScannerWrapper.isImageCaptureSupported()) {
            Log.d(TAG, "Device doesn't support image capture - generating mock image")
            return handleImageError("Image capture not supported", barcodeValue = lastBarcode)
        }

        // Пробуем получить изображение
        val xcImage = XCScannerWrapper.getLastDecodeImage()

        if (xcImage == null) {
            return handleImageError("No image available from scanner", barcodeValue = lastBarcode)
        }

        // Выводим подробную информацию о полученном изображении
        Log.d(TAG, "Image details: width=${xcImage.width}, height=${xcImage.height}, stride=${xcImage.stride}")
        Log.d(TAG, "Image format: ${xcImage.formatName}")

        // Получаем байтовый массив данных изображения
        val imageData = xcImage.data

        if (imageData == null) {
            return handleImageError("Image data is null", barcodeValue = lastBarcode)
        }

        Log.d(TAG, "Image data size: ${imageData.size} bytes")

        // Пробуем разные подходы преобразования в Bitmap
        val bitmap = try {
            // Сначала пробуем стандартный способ через BitmapFactory
            val standardBitmap = BitmapFactory.decodeByteArray(imageData, 0, imageData.size)
            if (standardBitmap != null) {
                Log.d(TAG, "Successfully created bitmap using standard decoder")
                standardBitmap
            } else {
                // Если стандартный способ не сработал, пробуем raw8 преобразование
                Log.d(TAG, "Standard bitmap conversion failed, trying raw8 conversion")
                raw8ToBitmap(imageData, xcImage.width, xcImage.height)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Standard conversion failed with exception: ${e.message}")
            // При ошибке пробуем raw8 преобразование
            raw8ToBitmap(imageData, xcImage.width, xcImage.height)
        }

        return bitmap ?: handleImageError("Failed to convert image data to bitmap", barcodeValue = lastBarcode)
    } catch (e: Exception) {
        return handleImageError("Error getting image from scanner", e, lastBarcode)
    }
}

/**
 * Преобразует 8-бит необработанные данные в Bitmap
 */
private fun raw8ToBitmap(data: ByteArray, width: Int, height: Int): Bitmap? {
    return try {
        Log.d(TAG, "Converting raw8 data to bitmap: ${width}x${height}, data size: ${data.size}")

        // Проверка на валидность размеров
        if (width <= 0 || height <= 0 || data.isEmpty()) {
            Log.e(TAG, "Invalid image dimensions or empty data")
            return null
        }

        // Проверяем, достаточно ли данных для создания изображения
        val expectedSize = width * height
        if (data.size < expectedSize) {
            Log.e(TAG, "Data size too small: got ${data.size}, need at least $expectedSize")
            return null
        }

        // Создаем RGBA массив (4 байта на пиксель)
        val rgbaData = ByteArray(width * height * 4)

        // Преобразуем данные: для каждого байта создаем пиксель RGBA
        // где R=G=B=исходное значение, A=255 (полная непрозрачность)
        for (i in 0 until minOf(data.size, width * height)) {
            rgbaData[i * 4 + 0] = data[i] // R
            rgbaData[i * 4 + 1] = data[i] // G
            rgbaData[i * 4 + 2] = data[i] // B
            rgbaData[i * 4 + 3] = (-1).toByte() // A (255)
        }

        // Создаем Bitmap и копируем данные
        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        bitmap.copyPixelsFromBuffer(ByteBuffer.wrap(rgbaData))

        Log.d(TAG, "Successfully converted raw8 data to bitmap")
        bitmap
    } catch (e: Exception) {
        Log.e(TAG, "Error converting raw8 to bitmap: ${e.message}")
        e.printStackTrace()
        null
    }
}

/**
 * Создает мок-изображение штрих-кода с визуализацией значения
 */
private fun createMockBarcodeImage(barcodeValue: String): Bitmap {
    // Размеры изображения
    val width = 800
    val height = 400

    // Создаем Bitmap
    val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
    val canvas = Canvas(bitmap)

    // Заполняем фон белым цветом
    canvas.drawColor(Color.WHITE)

    // Создаем Paint для рисования
    val paint = Paint().apply {
        color = Color.BLACK
        isAntiAlias = true
        style = Paint.Style.FILL
        textSize = 48f
        typeface = Typeface.DEFAULT_BOLD
    }

    // Получаем размеры текста
    val textBounds = Rect()
    paint.getTextBounds(barcodeValue, 0, barcodeValue.length, textBounds)

    // Рисуем значение штрих-кода
    canvas.drawText(
        barcodeValue,
        (width - textBounds.width()) / 2f,
        height / 2f + textBounds.height() / 2f,
        paint
    )

    // Рисуем простую имитацию штрих-кода (вертикальные линии)
    paint.strokeWidth = 3f

    val codeStartX = (width - textBounds.width()) / 2f - 40f
    val codeEndX = (width + textBounds.width()) / 2f + 40f
    val codeWidth = codeEndX - codeStartX
    val lineCount = barcodeValue.length * 3

    for (i in 0 until lineCount) {
        if (i % 3 != 0) continue  // Рисуем только каждую третью линию для разреженности

        val x = codeStartX + (codeWidth * i / lineCount)
        val lineHeight = (30 + (Math.random() * 70)).toFloat()
        val startY = (height / 2f) - lineHeight - 60  // Выше текста

        canvas.drawLine(x, startY, x, startY + lineHeight, paint)
    }

    // Рисуем надпись о том, что это мок-изображение
    paint.textSize = 32f
    val mockText = "Generated preview (API limitation)"
    paint.getTextBounds(mockText, 0, mockText.length, textBounds)
    canvas.drawText(
        mockText,
        (width - textBounds.width()) / 2f,
        height - 40f,
        paint
    )

    return bitmap
}

/**
 * Расширение для ScannerManager, вызываемое из основного метода cleanup()
 * для очистки ресурсов изображений
 */
internal fun ScannerManager.cleanupImageResources() {
    Log.d(TAG, "Cleaning up image resources")
    // В текущей реализации нет необходимости в дополнительной очистке
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/scanners/XCScannerWrapper.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/scanners/XCScannerWrapper.kt
package com.xelth.eckwms_movfast.scanners

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.os.RemoteException
import android.util.Log
import com.tools.XCImage
import com.xcheng.scanner.AimerMode
import com.xcheng.scanner.BarcodeType
import com.xcheng.scanner.FlashMode
import com.xcheng.scanner.LicenseState
import com.xcheng.scanner.NotificationType
import com.xcheng.scanner.OutputMethod
import com.xcheng.scanner.RegionSizeType
import com.xcheng.scanner.ScannerResult
import com.xcheng.scanner.TextCaseType
import com.xcheng.scanner.XcBarcodeScanner

/**
 * Kotlin wrapper for XCScanner SDK version 1.1.4
 * Provides a more Kotlin-friendly interface to interact with the scanner
 */
object XCScannerWrapper {
    private const val TAG = "XCScannerWrapper"
    private var isInitialized = false
    private var scanResultCallback: ((String) -> Unit)? = null
    private val mainHandler = Handler(Looper.getMainLooper())

    // Обновленный метод инициализации
    fun initialize(context: Context, callback: (String) -> Unit) {
        if (isInitialized) {
            Log.d(TAG, "Scanner already initialized")
            scanResultCallback = callback // Обновляем колбэк в любом случае
            return
        }

        scanResultCallback = callback
        Log.d(TAG, "⭐ Initializing XcBarcodeScanner...")

        // Используем анонимный класс вместо лямбды для лучшей обработки
        XcBarcodeScanner.init(context, object : ScannerResult {
            override fun onResult(result: String) {
                Log.d(TAG, "⭐⭐⭐ SCAN RESULT RECEIVED FROM SCANNER: $result")

                // Всегда выполняем колбэк в основном потоке
                mainHandler.post {
                    try {
                        scanResultCallback?.let { callback ->
                            Log.d(TAG, "Forwarding result to UI: $result")
                            callback(result)
                        } ?: Log.e(TAG, "scanResultCallback is null!")
                    } catch (e: Exception) {
                        Log.e(TAG, "Error in scan result callback", e)
                    }
                }
            }
        })

        isInitialized = true
        Log.d(TAG, "Scanner initialization complete")

        // Проверка состояния лицензии
        val licenseState = XcBarcodeScanner.getLicenseState()
        Log.d(TAG, "⭐ License state: ${getLicenseStateString(licenseState)}")

        if (licenseState != LicenseState.ACTIVED) {
            Log.d(TAG, "Attempting to activate license")
            XcBarcodeScanner.activateLicense()
        }
    }

    /**
     * Deinitialize the scanner SDK
     * @param context Application context
     */
    fun deinitialize(context: Context) {
        if (!isInitialized) return
        XcBarcodeScanner.deInit(context)
        isInitialized = false
        scanResultCallback = null
        Log.d(TAG, "Scanner deinitialized")
    }

    /**
     * Start scanning
     */
    fun startScan() {
        if (!isInitialized) {
            Log.e(TAG, "⚠️ Scanner not initialized")
            return
        }
        Log.d(TAG, "⭐ STARTING SCAN")
        XcBarcodeScanner.startScan()
    }

    /**
     * Stop scanning
     */
    fun stopScan() {
        if (!isInitialized) return
        Log.d(TAG, "⭐ STOPPING SCAN")
        XcBarcodeScanner.stopScan()
    }

    /**
     * Suspend scan service
     * This releases camera resources
     */
    fun suspendScanService() {
        if (!isInitialized) return
        XcBarcodeScanner.suspendScanService()
        Log.d(TAG, "Scan service suspended")
    }

    /**
     * Resume scan service
     */
    fun resumeScanService() {
        if (!isInitialized) return
        XcBarcodeScanner.resumeScanService()
        Log.d(TAG, "Scan service resumed")
    }

    /**
     * Check if scan service is suspended
     * @return true if suspended, false otherwise
     */
    fun isScanServiceSuspending(): Boolean {
        return XcBarcodeScanner.isScanServiceSuspending()
    }

    /**
     * Get service version
     * @return Service version string
     */
    fun getServiceVersion(): String {
        return XcBarcodeScanner.getServiceVersion()
    }

    /**
     * Get SDK version
     * @return SDK version string
     */
    fun getSdkVersion(context: Context): String {
        return XcBarcodeScanner.getSdkVersion(context)
    }

    /**
     * Enable or disable specific barcode type
     * @param barcodeType Type of barcode from BarcodeType
     * @param enabled true to enable, false to disable
     */
    fun enableBarcodeType(barcodeType: String, enabled: Boolean) {
        if (!isInitialized) return
        XcBarcodeScanner.enableBarcodeType(barcodeType, enabled)
        Log.d(TAG, "Barcode type $barcodeType ${if (enabled) "enabled" else "disabled"}")
    }

    /**
     * Check if specific barcode type is enabled
     * @param barcodeType Type of barcode from BarcodeType
     * @return true if enabled, false if disabled
     */
    fun isBarcodeTypeEnabled(barcodeType: String): Boolean {
        return XcBarcodeScanner.isBarcodeTypeEnabled(barcodeType)
    }

    /**
     * Set output method for scan results
     * @param outputMethod Output method from OutputMethod
     */
    fun setOutputMethod(outputMethod: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setOutputMethod(outputMethod)
        Log.d(TAG, "Output method set to $outputMethod")
    }

    /**
     * Set notification type for successful scans
     * @param notificationType Notification type from NotificationType
     */
    fun setSuccessNotification(notificationType: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setSuccessNotification(notificationType)
        Log.d(TAG, "Success notification set to $notificationType")
    }

    /**
     * Enable or disable LED indicator for successful scans
     * @param enabled true to enable, false to disable
     */
    fun enableSuccessIndicator(enabled: Boolean) {
        if (!isInitialized) return
        XcBarcodeScanner.enableSuccessIndicator(enabled)
        Log.d(TAG, "Success indicator ${if (enabled) "enabled" else "disabled"}")
    }

    /**
     * Set scan timeout in seconds
     * @param seconds Timeout in seconds (1-9)
     */
    fun setTimeout(seconds: Int) {
        if (!isInitialized) return
        val limitedSeconds = seconds.coerceIn(1, 9)
        XcBarcodeScanner.setTimeout(limitedSeconds)
        Log.d(TAG, "Timeout set to $limitedSeconds seconds")
    }

    /**
     * Set aimer light mode
     * @param aimerMode Mode from AimerMode
     */
    fun setAimerLightsMode(aimerMode: Int) {
        if (!isInitialized) return
        XcBarcodeScanner.setAimerLightsMode(aimerMode)
        Log.d(TAG, "Aimer lights mode set to $aimerMode")
    }

    /**
     * Set flash light mode
     * @param flashMode Mode from FlashMode
     */
    fun setFlashLightsMode(flashMode: Int) {
        if (!isInitialized) return
        XcBarcodeScanner.setFlashLightsMode(flashMode)
        Log.d(TAG, "Flash lights mode set to $flashMode")
    }

    /**
     * Set text case for scan results
     * @param textCase Text case from TextCaseType
     */
    fun setTextCase(textCase: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setTextCase(textCase)
        Log.d(TAG, "Text case set to $textCase")
    }

    /**
     * Set text prefix for scan results
     * @param prefix Prefix string
     */
    fun setTextPrefix(prefix: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setTextPrefix(prefix)
        Log.d(TAG, "Text prefix set to $prefix")
    }

    /**
     * Set text prefix2 for scan results
     * @param prefix2 Second prefix string
     */
    fun setTextPrefix2(prefix2: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setTextPrefix2(prefix2)
        Log.d(TAG, "Text prefix2 set to $prefix2")
    }

    /**
     * Set text suffix for scan results
     * @param suffix Suffix string
     */
    fun setTextSuffix(suffix: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setTextSuffix(suffix)
        Log.d(TAG, "Text suffix set to $suffix")
    }

    /**
     * Set text suffix2 for scan results
     * @param suffix2 Second suffix string
     */
    fun setTextSuffix2(suffix2: String) {
        if (!isInitialized) return
        XcBarcodeScanner.setTextSuffix1(suffix2) // Note: Method name is different in the SDK
        Log.d(TAG, "Text suffix2 set to $suffix2")
    }

    /**
     * Set loop scan interval in milliseconds
     * @param ms Interval in milliseconds
     */
    fun setLoopScanInterval(ms: Int) {
        if (!isInitialized) return
        XcBarcodeScanner.setLoopScanInterval(ms)
        Log.d(TAG, "Loop scan interval set to $ms ms")
    }

    /**
     * Check if loop scan is running
     * @return true if running, false otherwise
     */
    fun isLoopScanRunning(): Boolean {
        return XcBarcodeScanner.isLoopScanRunning()
    }

    /**
     * Start loop scan
     */
    fun startLoopScan() {
        if (!isInitialized) return
        XcBarcodeScanner.startLoopScan()
        Log.d(TAG, "Loop scan started")
    }

    /**
     * Stop loop scan
     */
    fun stopLoopScan() {
        if (!isInitialized) return
        XcBarcodeScanner.stopLoopScan()
        Log.d(TAG, "Loop scan stopped")
    }

    /**
     * Set multi-barcode scanning options
     * @param numberOfBarcodes Number of barcodes to scan (1-20)
     * @param fixedNumber true for fixed number, false for variable number
     */
    fun setMultiBarcodes(numberOfBarcodes: Int, fixedNumber: Boolean) {
        if (!isInitialized) return
        val limitedNumber = numberOfBarcodes.coerceIn(1, 20)
        XcBarcodeScanner.setMultiBarcodes(limitedNumber, fixedNumber)
        Log.d(TAG, "Multi barcodes set to $limitedNumber, fixed: $fixedNumber")
    }

    /**
     * Set scan region size
     * @param regionSize Region size from RegionSizeType
     */
    fun setScanRegionSize(regionSize: Int) {
        if (!isInitialized) return
        XcBarcodeScanner.setScanRegionSize(regionSize)
        Log.d(TAG, "Scan region size set to $regionSize")
    }

    /**
     * Load settings from storage
     */
    fun loadSettings() {
        if (!isInitialized) return
        XcBarcodeScanner.loadSettings()
        Log.d(TAG, "Settings loaded")
    }

    /**
     * Save settings to storage
     */
    fun saveSettings() {
        if (!isInitialized) return
        XcBarcodeScanner.saveSettings()
        Log.d(TAG, "Settings saved")
    }

    /**
     * Reset settings to default
     */
    fun resetSettings() {
        if (!isInitialized) return
        XcBarcodeScanner.resetSettings()
        Log.d(TAG, "Settings reset to default")
    }

// Replace the DataMatrix functions in XCScannerWrapper.kt with these versions

    /**
     * Set DataMatrix barcode format with separators (dummy implementation)
     * Note: This API does not seem available in current scanner SDK
     * @param withSeparators true to include separators, false to exclude
     */
    fun setDataMatrixWithSeparators(withSeparators: Boolean) {
        if (!isInitialized) return
        try {
            // Try reflection as a fallback if the direct method is not available
            val method = XcBarcodeScanner::class.java.getDeclaredMethod("setDataMatrixWithSeparators", Boolean::class.java)
            method.invoke(null, withSeparators)
            Log.d(TAG, "DataMatrix with separators: $withSeparators")
        } catch (e: Exception) {
            Log.w(TAG, "setDataMatrixWithSeparators not supported in this scanner version: ${e.message}")
        }
    }

    /**
     * Set maximum output length for DataMatrix barcodes (dummy implementation)
     * Note: This API does not seem available in current scanner SDK
     * @param maxLength Maximum length for output
     */
    fun setDataMatrixMaxOutputLength(maxLength: Int) {
        if (!isInitialized) return
        try {
            // Try reflection as a fallback if the direct method is not available
            val method = XcBarcodeScanner::class.java.getDeclaredMethod("setDataMatrixMaxOutputLength", Int::class.java)
            method.invoke(null, maxLength)
            Log.d(TAG, "DataMatrix max output length: $maxLength")
        } catch (e: Exception) {
            Log.w(TAG, "setDataMatrixMaxOutputLength not supported in this scanner version: ${e.message}")
        }
    }

    /**
     * Check if the device supports image capture
     * @return true if supported, false otherwise
     */
    fun isImageCaptureSupported(): Boolean {
        if (!isInitialized) return false

        // Check if the scanner service is available
        if (XcBarcodeScanner.a == null) {
            Log.d(TAG, "Image capture not supported: Scanner service reference is null")
            return false
        }

        return try {
            // Try a test call - this won't work if the device doesn't support images
            val testImage = getLastDecodeImage()
            testImage != null
        } catch (e: Exception) {
            Log.d(TAG, "Image capture not supported: ${e.message}")
            false
        }
    }

    /**
     * Gets the last decoded image from the scanner
     * ВАЖНО: Исправлена проблема с null-reference и обработкой ошибок
     * @return XCImage или null, если изображение недоступно
     */
    fun getLastDecodeImage(): XCImage? {
        if (!isInitialized) {
            Log.e(TAG, "Cannot get last decode image - scanner not initialized")
            return null
        }

        // Важная проверка на null сервиса сканера, которая отсутствует в SDK
        if (XcBarcodeScanner.a == null) {
            Log.e(TAG, "Scanner service reference is null - image retrieval not possible")
            return null
        }

        try {
            // Now it's safe to call the method with a non-null scanner service
            return XcBarcodeScanner.getLastDecodeImage()
        } catch (e: IllegalArgumentException) {
            // This specific error occurs when trying to read from Parcel
            Log.e(TAG, "Error parsing image data from scanner service (Ask Gemini)", e)
            return null
        } catch (e: RemoteException) {
            Log.e(TAG, "Remote service error while getting image", e)
            return null
        } catch (e: Exception) {
            Log.e(TAG, "Error getting last decode image", e)
            return null
        }
    }

    /**
     * Converts license state code to a readable string
     * @param state License state code
     * @return Human-readable license state
     */
    private fun getLicenseStateString(state: Int): String {
        return when(state) {
            LicenseState.INACTIVE -> "Inactive"
            LicenseState.ACTIVATING -> "Activating"
            LicenseState.ACTIVED -> "Activated"
            LicenseState.INVALID -> "Invalid"
            LicenseState.NETWORK_ISSUE -> "Network Issue"
            LicenseState.EXPIRED -> "Expired"
            else -> "Unknown state: $state"
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/navigation/Navigation.kt ---

package com.xelth.eckwms_movfast.ui.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.xelth.eckwms_movfast.ui.screens.ScannerScreen

@Composable
fun AppNavigation(navController: NavHostController) {
    NavHost(navController = navController, startDestination = "main") {
        composable("main") {
            // Замените на ваш главный экран или создайте простой заглушку
            MainScreenPlaceholder(navController = navController)
        }

        // Маршрут для сканера
        composable("scanner_screen") {
            ScannerScreen(
                onNavigateBack = {
                    navController.popBackStack()
                },
                onBarcodeScanned = { barcode ->
                    // Сохраняем результат сканирования в savedStateHandle
                    navController.previousBackStackEntry
                        ?.savedStateHandle
                        ?.set("scanned_barcode", barcode)

                    // Возвращаемся назад
                    navController.popBackStack()
                }
            )
        }
    }
}

// Временная заглушка для главного экрана
@Composable
fun MainScreenPlaceholder(navController: NavHostController) {
    // Здесь должен быть ваш главный экран
    // Это просто заглушка для примера
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ApiTestHelpDialog.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ApiTestHelpDialog.kt

package com.xelth.eckwms_movfast.ui.screens

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

/**
 * Dialog that explains scanner API tests
 */
@Composable
fun ApiTestHelpDialog(
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Scanner API Tests Help",
                style = MaterialTheme.typography.headlineSmall
            )
        },
        text = {
            Column(
                modifier = Modifier
                    .verticalScroll(rememberScrollState())
                    .padding(vertical = 8.dp)
            ) {
                Text(
                    text = "These tests check if the scanner hardware and API are functioning correctly.",
                    style = MaterialTheme.typography.bodyMedium
                )

                Divider(modifier = Modifier.padding(vertical = 8.dp))

                // Run All Tests
                Text(
                    text = "Run All Tests",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Executes all available scanner API tests to check overall functionality. Results are displayed with pass/fail status for each test.",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                // Test Barcode Types
                Text(
                    text = "Test Barcode Types",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Verifies if the scanner can recognize and toggle support for different barcode types (QR Code, Code 128, EAN-13, etc.).",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                // Test Settings
                Text(
                    text = "Test Settings",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Checks if scanner settings like flash mode, aimer mode, output method, and notification types can be successfully configured.",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                // Test Image API
                Text(
                    text = "Test Image API",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Verifies if the scanner can capture and process barcode images. This tests if the movFast device's camera and decoder functions are working properly.",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                Divider(modifier = Modifier.padding(vertical = 8.dp))

                // Understanding Results
                Text(
                    text = "Understanding Results",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "• Green checkmarks (✓) indicate passed tests\n" +
                            "• Red X marks (✗) indicate failed tests\n" +
                            "• The percentage at the bottom shows overall test success rate\n" +
                            "• Expand individual test results to see detailed messages",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                Divider(modifier = Modifier.padding(vertical = 8.dp))

                // Troubleshooting
                Text(
                    text = "Troubleshooting",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "If tests fail, try these steps:\n" +
                            "1. Restart the application\n" +
                            "2. Check if scanner service is running\n" +
                            "3. Verify device permissions\n" +
                            "4. Ensure scanner hardware is not in use by another app\n" +
                            "5. Contact technical support if issues persist",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("Close")
            }
        }
    )
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ImageViewerScreen.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ImageViewerScreen.kt
package com.xelth.eckwms_movfast.ui.screens

import android.util.Log
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImagePainter
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import coil.size.Size

private const val TAG = "ImageViewerScreen"

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ImageViewerSection(
    imageUrls: List<String>,
    modifier: Modifier = Modifier
) {
    if (imageUrls.isEmpty()) {
        Card(
            modifier = modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .padding(16.dp),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "No images available from server",
                    style = MaterialTheme.typography.bodyLarge
                )
            }
        }
        return
    }

    // Create pager state
    val pagerState = rememberPagerState { imageUrls.size }

    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Server Images",
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Image pager
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(240.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(Color.Black.copy(alpha = 0.05f))
            ) {
                HorizontalPager(
                    state = pagerState,
                    modifier = Modifier.fillMaxSize()
                ) { page ->
                    val imageUrl = imageUrls[page]
                    ImageItem(imageUrl = imageUrl)
                }

                // Loading indicator overlay - only shown when loading
                ImageLoadingOverlay(
                    modifier = Modifier.fillMaxSize(),
                    imageUrl = imageUrls[pagerState.currentPage]
                )

                // Image counter
                Box(
                    modifier = Modifier
                        .align(Alignment.BottomEnd)
                        .padding(8.dp)
                        .clip(RoundedCornerShape(4.dp))
                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = "${pagerState.currentPage + 1}/${imageUrls.size}",
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Pager indicator dots
            if (imageUrls.size > 1) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.Center
                ) {
                    repeat(imageUrls.size) { index ->
                        val selected = pagerState.currentPage == index
                        Box(
                            modifier = Modifier
                                .padding(horizontal = 4.dp)
                                .size(if (selected) 10.dp else 8.dp)
                                .clip(CircleShape)
                                .background(
                                    if (selected)
                                        MaterialTheme.colorScheme.primary
                                    else
                                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
                                )
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ImageItem(
    imageUrl: String,
    modifier: Modifier = Modifier
) {
    val painter = rememberAsyncImagePainter(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .size(Size.ORIGINAL)
            .crossfade(true)
            .build()
    )

    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        // When the Success state has been reached, we know the image has loaded
        if (painter.state is AsyncImagePainter.State.Success) {
            Image(
                painter = painter,
                contentDescription = "Server image",
                modifier = Modifier.fillMaxSize(),
                contentScale = ContentScale.Fit
            )
        } else if (painter.state !is AsyncImagePainter.State.Loading &&
            painter.state !is AsyncImagePainter.State.Error) {
            // For any other state that's not Loading or Error, still show the image
            // This covers cases where the image might be partially loaded or in another state
            Image(
                painter = painter,
                contentDescription = "Server image",
                modifier = Modifier.fillMaxSize(),
                contentScale = ContentScale.Fit
            )
        }
        // Loading and Error states are handled by the ImageLoadingOverlay
    }
}

@Composable
private fun ImageLoadingOverlay(
    imageUrl: String,
    modifier: Modifier = Modifier
) {
    // We'll create a separate painter just for tracking the loading state
    // This avoids the issue with the main painter showing loading even after the image is displayed
    val statePainter = rememberAsyncImagePainter(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .build()
    )

    val isLoading = statePainter.state is AsyncImagePainter.State.Loading
    val isError = statePainter.state is AsyncImagePainter.State.Error

    // Only show the overlay if actually loading or error
    if (isLoading || isError) {
        Box(modifier = modifier, contentAlignment = Alignment.Center) {
            if (isLoading) {
                CircularProgressIndicator(
                    color = MaterialTheme.colorScheme.primary
                )
            } else if (isError) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.padding(16.dp)
                ) {
                    // Use a simple error icon instead of the painter to avoid confusion
                    Box(
                        modifier = Modifier
                            .size(48.dp)
                            .background(MaterialTheme.colorScheme.error.copy(alpha = 0.1f), CircleShape),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "!",
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.headlineLarge,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Error loading image",
                        color = MaterialTheme.colorScheme.error,
                        textAlign = TextAlign.Center
                    )
                }
            }
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannedImageScreen.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannedImageScreen.kt
// Улучшенный экран просмотра изображения штрихкода с обработкой API-ограничений
package com.xelth.eckwms_movfast.ui.screens

import android.graphics.Bitmap
import android.util.Log
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.xelth.eckwms_movfast.scanners.ScannerManager
import com.xelth.eckwms_movfast.scanners.getLastDecodedImage

private const val TAG = "ScannedImageScreen"
private const val MIN_SCALE = 1.0f
private const val MAX_SCALE = 5.0f

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ScannedImageScreen(
    scannerManager: ScannerManager,
    onNavigateBack: () -> Unit
) {
    var bitmap by remember { mutableStateOf<Bitmap?>(null) }
    var scale by remember { mutableFloatStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    var isGeneratedImage by remember { mutableStateOf(false) }

    // Наблюдаем за последними отсканированными данными для контекста
    val latestScanResult by scannerManager.scanResult.observeAsState()

    // Загрузка изображения при отображении экрана
    // Add this to the LaunchedEffect block in ScannedImageScreen.kt
    LaunchedEffect(Unit) {
        try {
            Log.d(TAG, "Attempting to load the last decoded image")

            // Check if image capture is supported
            val isSupported = scannerManager.isImageCaptureSupported()
            if (!isSupported) {
                isGeneratedImage = true
                Log.d(TAG, "Image capture not supported on this device")
            }

            bitmap = scannerManager.getLastDecodedImage()

            if (bitmap == null) {
                Log.d(TAG, "No image available")
                errorMessage = "Изображение не найдено. Отсканируйте штрих-код, чтобы увидеть его визуализацию."
            } else {
                Log.d(TAG, "Image loaded successfully: ${bitmap?.width}x${bitmap?.height}")
                // Проверяем, является ли это сгенерированным изображением - размеры 800x400
                isGeneratedImage = bitmap!!.width == 800 && bitmap!!.height == 400
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading image", e)
            errorMessage = "Ошибка загрузки изображения: ${e.message}"
        }
    }



    // Состояние для трансформации (масштабирование и смещение)
    val transformableState = rememberTransformableState { zoomChange, panChange, _ ->
        // Обновляем масштаб с ограничениями
        scale = (scale * zoomChange).coerceIn(MIN_SCALE, MAX_SCALE)

        // Обновляем смещение
        offset += panChange * scale
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Просмотр изображения") },
                navigationIcon = {
                    TextButton(onClick = onNavigateBack) {
                        Text("← Назад")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Информация о последнем отсканированном штрих-коде
            if (!latestScanResult.isNullOrEmpty()) {
                Text(
                    text = "Штрих-код: $latestScanResult",
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
            }

            // Предупреждение о сгенерированном изображении
            if (isGeneratedImage) {
                Text(
                    text = "Примечание: API сканера не поддерживает получение реального изображения, " +
                            "отображается визуализация штрих-кода.",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.error,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
            }

            // Контроллеры масштабирования
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Button(
                    onClick = { scale = (scale - 0.5f).coerceAtLeast(MIN_SCALE) },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("−", fontWeight = FontWeight.Bold)
                }

                Spacer(modifier = Modifier.width(8.dp))

                Slider(
                    value = scale,
                    onValueChange = { scale = it },
                    valueRange = MIN_SCALE..MAX_SCALE,
                    modifier = Modifier.weight(2f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                Button(
                    onClick = { scale = (scale + 0.5f).coerceAtMost(MAX_SCALE) },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("+", fontWeight = FontWeight.Bold)
                }
            }

            Text(
                text = "Масштаб: ${String.format("%.1f", scale)}x",
                style = MaterialTheme.typography.labelMedium,
                modifier = Modifier.padding(bottom = 8.dp)
            )

            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .background(Color.Black.copy(alpha = 0.1f)),
                contentAlignment = Alignment.Center
            ) {
                if (bitmap != null) {
                    Image(
                        bitmap = bitmap!!.asImageBitmap(),
                        contentDescription = "Отсканированное изображение",
                        contentScale = ContentScale.Fit,
                        modifier = Modifier
                            .fillMaxSize()
                            .graphicsLayer {
                                scaleX = scale
                                scaleY = scale
                                translationX = offset.x
                                translationY = offset.y
                            }
                            .transformable(transformableState)
                    )
                } else if (errorMessage != null) {
                    Text(
                        text = errorMessage!!,
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.padding(16.dp)
                    )
                } else {
                    Text(
                        text = "Загрузка изображения...",
                        style = MaterialTheme.typography.bodyLarge
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            Button(
                onClick = {
                    offset = Offset.Zero
                    scale = 1f
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Сбросить масштаб")
            }

            if (bitmap != null) {
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Размер изображения: ${bitmap!!.width}x${bitmap!!.height}",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannerScreen.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannerScreen.kt
package com.xelth.eckwms_movfast.ui.screens

import android.app.Activity
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.xcheng.scanner.AimerMode
import com.xcheng.scanner.BarcodeType
import com.xcheng.scanner.FlashMode
import com.xcheng.scanner.NotificationType
import com.xcheng.scanner.OutputMethod
import com.xcheng.scanner.RegionSizeType
import com.xcheng.scanner.TextCaseType
import com.xelth.eckwms_movfast.scanners.XCScannerWrapper

private const val TAG = "ScannerScreen"

// Константы для broadcast
private const val SCAN_ACTION = "com.xcheng.scanner.action.BARCODE_DECODING_BROADCAST"
private const val SCAN_DATA_KEY = "EXTRA_BARCODE_DECODING_DATA"

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ScannerScreen(
    onNavigateBack: () -> Unit,
    onBarcodeScanned: (String) -> Unit
) {
    val context = LocalContext.current
    var scanResult by remember { mutableStateOf("Scan result will appear here") }
    var isScanning by remember { mutableStateOf(false) }
    var isLoopScanning by remember { mutableStateOf(false) }

    // Для BroadcastReceiver
    var scanReceiver: BroadcastReceiver? = null

    // Dropdown state
    var selectedBarcodeType by remember { mutableStateOf("QR Code") }
    var selectedFlashMode by remember { mutableStateOf("Illuminate Only") }
    var selectedAimerMode by remember { mutableStateOf("On During Scan") }

    // Dropdown expanded state
    var barcodeTypeExpanded by remember { mutableStateOf(false) }
    var flashModeExpanded by remember { mutableStateOf(false) }
    var aimerModeExpanded by remember { mutableStateOf(false) }

    // Barcode type mapping
    val barcodeTypes = remember {
        listOf(
            "QR Code" to BarcodeType.QRCODE,
            "Code 128" to BarcodeType.CODE128,
            "Code 39" to BarcodeType.CODE39,
            "EAN-13" to BarcodeType.EAN13,
            "EAN-8" to BarcodeType.EAN8,
            "UPC-A" to BarcodeType.UPCA,
            "UPC-E" to BarcodeType.UPCE,
            "DataMatrix" to BarcodeType.DATAMATRIX,
            "PDF417" to BarcodeType.PDF417
        )
    }

    // Flash mode mapping
    val flashModes = remember {
        listOf(
            "Off" to FlashMode.OFF,
            "Illuminate Only" to FlashMode.ILLUME_ONLY,
            "Illuminate with Strobe" to FlashMode.ILLUME_STROBE
        )
    }

    // Aimer mode mapping
    val aimerModes = remember {
        listOf(
            "Always Off" to AimerMode.ALWAYS_OFF,
            "On During Scan" to AimerMode.TRIGGER_ON,
            "Always On" to AimerMode.ALWAYS_ON
        )
    }

    // Инициализация сканера при отображении экрана
    LaunchedEffect(Unit) {
        Log.d(TAG, "⭐ Инициализация сканера начинается...")

        // Инициализация XCScannerWrapper
        XCScannerWrapper.initialize(context) { result ->
            Log.d(TAG, "⭐ Scan result received via SDK callback: $result")
            scanResult = "Отсканировано (SDK): $result"
            onBarcodeScanned(result)
        }

        // Настройка сканера
        configureScanner(context)

        // Регистрируем BroadcastReceiver для получения результатов сканирования
        scanReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                Log.d(TAG, "⭐ BroadcastReceiver получил Intent: ${intent.action}")

                // Проверяем, что это именно наш action
                if (intent.action == SCAN_ACTION) {
                    val barcode = intent.getStringExtra(SCAN_DATA_KEY)

                    if (barcode != null) {
                        Log.d(TAG, "⭐⭐⭐ Получен штрих-код через broadcast: $barcode")

                        // Обновляем UI в главном потоке
                        (context as? Activity)?.runOnUiThread {
                            scanResult = "Отсканировано: $barcode"
                            onBarcodeScanned(barcode)
                        }
                    } else {
                        Log.d(TAG, "⚠️ Intent не содержит данных по ключу $SCAN_DATA_KEY")
                        // Проверяем все extras для отладки
                        intent.extras?.keySet()?.forEach { key ->
                            Log.d(TAG, "  Ключ: $key, Значение: ${intent.extras?.get(key)}")
                        }
                    }
                }
            }
        }

        // Регистрируем BroadcastReceiver с конкретным фильтром
        val intentFilter = IntentFilter(SCAN_ACTION)
        context.registerReceiver(scanReceiver, intentFilter)

        Log.d(TAG, "⭐ ScannerScreen настроен и готов к сканированию")
    }

    // Очистка ресурсов при закрытии экрана
    DisposableEffect(Unit) {
        onDispose {
            Log.d(TAG, "⭐ Очистка ресурсов ScannerScreen")

            if (isScanning) {
                XCScannerWrapper.stopScan()
            }

            if (isLoopScanning) {
                XCScannerWrapper.stopLoopScan()
            }

            // Отменяем регистрацию BroadcastReceiver
            scanReceiver?.let {
                try {
                    context.unregisterReceiver(it)
                    Log.d(TAG, "✓ BroadcastReceiver отменен")
                } catch (e: Exception) {
                    Log.e(TAG, "Ошибка при отмене регистрации BroadcastReceiver", e)
                }
            }

            XCScannerWrapper.deinitialize(context)
            Log.d(TAG, "✓ Ресурсы ScannerScreen очищены")
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Barcode Scanner") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Result Card
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                shape = RoundedCornerShape(8.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = "Scan Result",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .background(Color.LightGray.copy(alpha = 0.3f), RoundedCornerShape(4.dp))
                            .padding(16.dp)
                    ) {
                        Text(
                            text = scanResult,
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }
            }

            // Settings Card
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                shape = RoundedCornerShape(8.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Scanner Settings",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )

                    // Barcode Type Dropdown
                    Column {
                        Text("Barcode Type", fontWeight = FontWeight.Bold)
                        Box {
                            TextButton(
                                onClick = { barcodeTypeExpanded = true },
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Text(
                                    text = selectedBarcodeType,
                                    modifier = Modifier.weight(1f),
                                    textAlign = TextAlign.Start
                                )
                                Icon(Icons.Default.ArrowDropDown, "Dropdown Arrow")
                            }
                            DropdownMenu(
                                expanded = barcodeTypeExpanded,
                                onDismissRequest = { barcodeTypeExpanded = false },
                                modifier = Modifier.fillMaxWidth(0.9f)
                            ) {
                                barcodeTypes.forEach { (name, type) ->
                                    DropdownMenuItem(
                                        text = { Text(name) },
                                        onClick = {
                                            selectedBarcodeType = name
                                            barcodeTypeExpanded = false

                                            // Включаем только выбранный тип штрих-кода
                                            barcodeTypes.forEach { (_, barcodeType) ->
                                                XCScannerWrapper.enableBarcodeType(barcodeType, barcodeType == type)
                                            }

                                            Log.d(TAG, "Selected barcode type: $name")
                                        }
                                    )
                                }
                            }
                        }
                    }

                    Divider()

                    // Flash Mode Dropdown
                    Column {
                        Text("Flash Mode", fontWeight = FontWeight.Bold)
                        Box {
                            TextButton(
                                onClick = { flashModeExpanded = true },
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Text(
                                    text = selectedFlashMode,
                                    modifier = Modifier.weight(1f),
                                    textAlign = TextAlign.Start
                                )
                                Icon(Icons.Default.ArrowDropDown, "Dropdown Arrow")
                            }
                            DropdownMenu(
                                expanded = flashModeExpanded,
                                onDismissRequest = { flashModeExpanded = false },
                                modifier = Modifier.fillMaxWidth(0.9f)
                            ) {
                                flashModes.forEach { (name, mode) ->
                                    DropdownMenuItem(
                                        text = { Text(name) },
                                        onClick = {
                                            selectedFlashMode = name
                                            flashModeExpanded = false
                                            XCScannerWrapper.setFlashLightsMode(mode)
                                            Log.d(TAG, "Selected flash mode: $name")
                                        }
                                    )
                                }
                            }
                        }
                    }

                    Divider()

                    // Aimer Mode Dropdown
                    Column {
                        Text("Aimer Mode", fontWeight = FontWeight.Bold)
                        Box {
                            TextButton(
                                onClick = { aimerModeExpanded = true },
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Text(
                                    text = selectedAimerMode,
                                    modifier = Modifier.weight(1f),
                                    textAlign = TextAlign.Start
                                )
                                Icon(Icons.Default.ArrowDropDown, "Dropdown Arrow")
                            }
                            DropdownMenu(
                                expanded = aimerModeExpanded,
                                onDismissRequest = { aimerModeExpanded = false },
                                modifier = Modifier.fillMaxWidth(0.9f)
                            ) {
                                aimerModes.forEach { (name, mode) ->
                                    DropdownMenuItem(
                                        text = { Text(name) },
                                        onClick = {
                                            selectedAimerMode = name
                                            aimerModeExpanded = false
                                            XCScannerWrapper.setAimerLightsMode(mode)
                                            Log.d(TAG, "Selected aimer mode: $name")
                                        }
                                    )
                                }
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Тестовая кнопка для эмуляции сканирования (для отладки)
            Button(
                onClick = {
                    Log.d(TAG, "⭐ Test scan button clicked")
                    scanResult = "TEST: Generated test barcode"
                    onBarcodeScanned("TEST123456789")
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Generate Test Barcode")
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Scan Buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Button(
                    onClick = {
                        Log.d(TAG, "⭐ Scan button clicked, current state: ${if (isScanning) "scanning" else "not scanning"}")
                        if (isScanning) {
                            XCScannerWrapper.stopScan()
                            Log.d(TAG, "⭐ STOPPING SCAN")
                        } else {
                            XCScannerWrapper.startScan()
                            Log.d(TAG, "⭐ STARTING SCAN")
                        }
                        isScanning = !isScanning
                        Log.d(TAG, "⭐ Scan state changed to: ${if (isScanning) "scanning" else "not scanning"}")
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text(if (isScanning) "Stop Scan" else "Start Scan")
                }

                Button(
                    onClick = {
                        Log.d(TAG, "⭐ Loop scan button clicked, current state: ${if (isLoopScanning) "loop scanning" else "not loop scanning"}")
                        if (isLoopScanning) {
                            XCScannerWrapper.stopLoopScan()
                            Log.d(TAG, "⭐ STOPPING LOOP SCAN")
                        } else {
                            XCScannerWrapper.setLoopScanInterval(500) // 500ms interval
                            XCScannerWrapper.startLoopScan()
                            Log.d(TAG, "⭐ STARTING LOOP SCAN")
                        }
                        isLoopScanning = !isLoopScanning
                        Log.d(TAG, "⭐ Loop scan state changed to: ${if (isLoopScanning) "loop scanning" else "not loop scanning"}")
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text(if (isLoopScanning) "Stop Loop Scan" else "Start Loop Scan")
                }
            }
        }
    }
}

/**
 * Настраивает сканер с оптимальными параметрами
 */
private fun configureScanner(context: Context) {
    Log.d(TAG, "⭐ Configuring scanner with improved settings...")

    // Настройка вывода для работы с broadcast
    XCScannerWrapper.setOutputMethod(OutputMethod.BROADCAST)

    // Максимальная область сканирования
    XCScannerWrapper.setScanRegionSize(RegionSizeType.VIEWSIZE_100)

    // Максимальное время сканирования
    XCScannerWrapper.setTimeout(9)

    // Звуковое и вибро-оповещение при успешном сканировании
    XCScannerWrapper.setSuccessNotification(NotificationType.SOUND_VIBRATOR)

    // Включить LED-индикатор при успешном сканировании
    XCScannerWrapper.enableSuccessIndicator(true)

    // Настройка обработки текста
    XCScannerWrapper.setTextCase(TextCaseType.NONE)

    // Включить распознавание всех основных типов штрих-кодов
    XCScannerWrapper.enableBarcodeType(BarcodeType.QRCODE, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.CODE128, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.CODE39, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.EAN13, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.EAN8, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.UPCA, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.UPCE, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.DATAMATRIX, true)
    XCScannerWrapper.enableBarcodeType(BarcodeType.PDF417, true)

    Log.d(TAG, "⭐ Scanner configuration complete with all barcode types enabled")
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannerSettingsScreen.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/ScannerSettingsScreen.kt
package com.xelth.eckwms_movfast.ui.screens

import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.xcheng.scanner.AimerMode
import com.xcheng.scanner.BarcodeType
import com.xcheng.scanner.FlashMode
import com.xcheng.scanner.NotificationType
import com.xcheng.scanner.OutputMethod
import com.xcheng.scanner.RegionSizeType
import com.xcheng.scanner.TextCaseType
import com.xelth.eckwms_movfast.diagnostics.FunctionTestResult
import com.xelth.eckwms_movfast.diagnostics.ScannerApiTester
import com.xelth.eckwms_movfast.scanners.ScannerManager
import com.xelth.eckwms_movfast.scanners.XCScannerWrapper
import kotlinx.coroutines.launch

private const val TAG = "ScannerSettingsScreen"

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ScannerSettingsScreen(
    scannerManager: ScannerManager,
    onNavigateBack: () -> Unit,
    onOpenImageViewer: () -> Unit
) {
    // Наблюдаем за последним отсканированным штрих-кодом
    val latestScanResult by scannerManager.scanResult.observeAsState()
    val scrollState = rememberScrollState()

    // Состояние для отслеживания переключения на API тестирование
    var showApiTestingSection by remember { mutableStateOf(false) }

    // Для логгирования ошибок
    val context = LocalContext.current
    val errorMessages = remember { mutableStateListOf<String>() }

    // Обработка потенциальных ошибок инициализации
    LaunchedEffect(Unit) {
        try {
            val isInitialized = scannerManager.isInitialized()
            Log.d(TAG, "Scanner initialization status: $isInitialized")

            if (!isInitialized) {
                errorMessages.add("Scanner not initialized. Attempting to initialize...")
                scannerManager.initialize()
                if (scannerManager.isInitialized()) {
                    errorMessages.add("Scanner initialized successfully.")
                } else {
                    errorMessages.add("Failed to initialize scanner.")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking scanner initialization", e)
            errorMessages.add("Error checking scanner: ${e.message}")
        }
    }

    // Dropdown state
    var selectedBarcodeType by remember { mutableStateOf("QR Code") }
    var selectedFlashMode by remember { mutableStateOf("Illuminate Only") }
    var selectedAimerMode by remember { mutableStateOf("On During Scan") }

    // Dropdown expanded state
    var barcodeTypeExpanded by remember { mutableStateOf(false) }
    var flashModeExpanded by remember { mutableStateOf(false) }
    var aimerModeExpanded by remember { mutableStateOf(false) }

    // Barcode type mapping
    val barcodeTypes = remember {
        listOf(
            "QR Code" to BarcodeType.QRCODE,
            "Code 128" to BarcodeType.CODE128,
            "Code 39" to BarcodeType.CODE39,
            "EAN-13" to BarcodeType.EAN13,
            "EAN-8" to BarcodeType.EAN8,
            "UPC-A" to BarcodeType.UPCA,
            "UPC-E" to BarcodeType.UPCE,
            "DataMatrix" to BarcodeType.DATAMATRIX,
            "PDF417" to BarcodeType.PDF417
        )
    }

    // Flash mode mapping
    val flashModes = remember {
        listOf(
            "Off" to FlashMode.OFF,
            "Illuminate Only" to FlashMode.ILLUME_ONLY,
            "Illuminate with Strobe" to FlashMode.ILLUME_STROBE
        )
    }

    // Aimer mode mapping
    val aimerModes = remember {
        listOf(
            "Always Off" to AimerMode.ALWAYS_OFF,
            "On During Scan" to AimerMode.TRIGGER_ON,
            "Always On" to AimerMode.ALWAYS_ON
        )
    }

    // Отслеживаем, запущено ли непрерывное сканирование
    var isLoopScanActive by remember { mutableStateOf(scannerManager.isLoopScanRunning()) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Scanner Settings") },
                navigationIcon = {
                    TextButton(onClick = onNavigateBack) {
                        Text("← Back")
                    }
                },
                actions = {
                    TextButton(onClick = onOpenImageViewer) {
                        Text("View Image")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,
                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Переключатель для API Testing Section
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { showApiTestingSection = !showApiTestingSection },
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                colors = CardDefaults.cardColors(
                    containerColor = if (showApiTestingSection)
                        MaterialTheme.colorScheme.primaryContainer
                    else
                        MaterialTheme.colorScheme.surface
                )
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text(
                        text = "API Testing Tools",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = if (showApiTestingSection)
                            MaterialTheme.colorScheme.onPrimaryContainer
                        else
                            MaterialTheme.colorScheme.onSurface
                    )

                    // Индикатор состояния
                    Text(
                        text = if (showApiTestingSection) "▼" else "▶",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                }
            }

            // Отображение ошибок, если они есть
            if (errorMessages.isNotEmpty()) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Diagnostic Messages:",
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onErrorContainer
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        errorMessages.forEach { message ->
                            Text(
                                text = "• $message",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onErrorContainer
                            )
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        TextButton(
                            onClick = { errorMessages.clear() },
                            modifier = Modifier.align(Alignment.End)
                        ) {
                            Text("Clear Messages")
                        }
                    }
                }
            }

            // Result Card
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                shape = RoundedCornerShape(8.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = "Scan Result",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .background(Color.LightGray.copy(alpha = 0.3f), RoundedCornerShape(4.dp))
                            .padding(16.dp)
                    ) {
                        Text(
                            text = latestScanResult ?: "No scan results yet",
                            modifier = Modifier.fillMaxWidth()
                        )
                    }

                    Spacer(modifier = Modifier.height(8.dp))

                    Button(
                        onClick = onOpenImageViewer,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("View Scanned Image")
                    }
                }
            }

            // Показываем либо API тесты, либо обычные настройки в зависимости от состояния
            if (showApiTestingSection) {
                ApiTestsSection(scannerManager)
            } else {
                // Settings Card
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                    shape = RoundedCornerShape(8.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Text(
                            text = "Scanner Settings",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold
                        )

                        // Barcode Type Dropdown
                        Column {
                            Text("Barcode Type", fontWeight = FontWeight.Bold)
                            Box {
                                TextButton(
                                    onClick = { barcodeTypeExpanded = true },
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text(
                                        text = selectedBarcodeType,
                                        modifier = Modifier.weight(1f),
                                        textAlign = TextAlign.Start
                                    )
                                    Text("▼")
                                }
                                DropdownMenu(
                                    expanded = barcodeTypeExpanded,
                                    onDismissRequest = { barcodeTypeExpanded = false },
                                    modifier = Modifier.fillMaxWidth(0.9f)
                                ) {
                                    barcodeTypes.forEach { (name, type) ->
                                        DropdownMenuItem(
                                            text = { Text(name) },
                                            onClick = {
                                                selectedBarcodeType = name
                                                barcodeTypeExpanded = false

                                                try {
                                                    // Включаем только выбранный тип штрих-кода
                                                    barcodeTypes.forEach { (_, barcodeType) ->
                                                        scannerManager.enableBarcodeType(barcodeType, barcodeType == type)
                                                    }
                                                    Log.d(TAG, "Selected barcode type: $name")
                                                } catch (e: Exception) {
                                                    Log.e(TAG, "Error setting barcode type", e)
                                                    errorMessages.add("Error setting barcode type: ${e.message}")
                                                }
                                            }
                                        )
                                    }
                                }
                            }
                        }

                        Divider()

                        // Flash Mode Dropdown
                        Column {
                            Text("Flash Mode", fontWeight = FontWeight.Bold)
                            Box {
                                TextButton(
                                    onClick = { flashModeExpanded = true },
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text(
                                        text = selectedFlashMode,
                                        modifier = Modifier.weight(1f),
                                        textAlign = TextAlign.Start
                                    )
                                    Text("▼")
                                }
                                DropdownMenu(
                                    expanded = flashModeExpanded,
                                    onDismissRequest = { flashModeExpanded = false },
                                    modifier = Modifier.fillMaxWidth(0.9f)
                                ) {
                                    flashModes.forEach { (name, mode) ->
                                        DropdownMenuItem(
                                            text = { Text(name) },
                                            onClick = {
                                                selectedFlashMode = name
                                                flashModeExpanded = false
                                                try {
                                                    scannerManager.setFlashLightsMode(mode)
                                                    Log.d(TAG, "Selected flash mode: $name")
                                                } catch (e: Exception) {
                                                    Log.e(TAG, "Error setting flash mode", e)
                                                    errorMessages.add("Error setting flash mode: ${e.message}")
                                                }
                                            }
                                        )
                                    }
                                }
                            }
                        }

                        Divider()

                        // Aimer Mode Dropdown
                        Column {
                            Text("Aimer Mode", fontWeight = FontWeight.Bold)
                            Box {
                                TextButton(
                                    onClick = { aimerModeExpanded = true },
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text(
                                        text = selectedAimerMode,
                                        modifier = Modifier.weight(1f),
                                        textAlign = TextAlign.Start
                                    )
                                    Text("▼")
                                }
                                DropdownMenu(
                                    expanded = aimerModeExpanded,
                                    onDismissRequest = { aimerModeExpanded = false },
                                    modifier = Modifier.fillMaxWidth(0.9f)
                                ) {
                                    aimerModes.forEach { (name, mode) ->
                                        DropdownMenuItem(
                                            text = { Text(name) },
                                            onClick = {
                                                selectedAimerMode = name
                                                aimerModeExpanded = false
                                                try {
                                                    scannerManager.setAimerLightsMode(mode)
                                                    Log.d(TAG, "Selected aimer mode: $name")
                                                } catch (e: Exception) {
                                                    Log.e(TAG, "Error setting aimer mode", e)
                                                    errorMessages.add("Error setting aimer mode: ${e.message}")
                                                }
                                            }
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Scan Button
            Button(
                onClick = {
                    Log.d(TAG, "⭐ Toggle scan button clicked, current state: ${if (isLoopScanActive) "scanning" else "not scanning"}")
                    try {
                        if (isLoopScanActive) {
                            scannerManager.stopLoopScan()
                        } else {
                            scannerManager.startLoopScan(500) // 500ms интервал
                        }
                        isLoopScanActive = !isLoopScanActive
                        Log.d(TAG, "⭐ Scan state changed to: ${if (isLoopScanActive) "scanning" else "not scanning"}")
                    } catch (e: Exception) {
                        Log.e(TAG, "Error toggling scan", e)
                        errorMessages.add("Error toggling scan: ${e.message}")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(if (isLoopScanActive) "Stop Continuous Scanning" else "Start Continuous Scanning")
            }
        }
    }
}

/**
 * Выделение секции тестирования API в отдельный компонент
 */
@Composable
fun ApiTestsSection(scannerManager: ScannerManager) {
    val coroutineScope = rememberCoroutineScope()

    // States for the API testing UI
    val apiTestResults = remember { mutableStateListOf<FunctionTestResult>() }
    var isTestRunning by remember { mutableStateOf(false) }

    // Help dialog state
    var showHelpDialog by remember { mutableStateOf(false) }

    if (showHelpDialog) {
        ApiTestHelpDialog(onDismiss = { showHelpDialog = false })
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Header with help button
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                // Title
                Text(
                    text = "Scanner API Tests",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold
                )

                // Help button
                TextButton(
                    onClick = { showHelpDialog = true },
                    modifier = Modifier.padding(horizontal = 4.dp)
                ) {
                    Text("?")
                }
            }

            // Test content section
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    text = "Run tests to verify scanner API functionality",
                    style = MaterialTheme.typography.bodyMedium
                )

                // Test buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    // Basic scanner functionality test
                    OutlinedButton(
                        onClick = {
                            if (!isTestRunning) {
                                isTestRunning = true
                                apiTestResults.clear()

                                coroutineScope.launch {
                                    try {
                                        // Run the tests
                                        val tester = ScannerApiTester(scannerManager)
                                        val results = tester.runUIFriendlyTests()

                                        // Update the UI with results
                                        apiTestResults.clear()
                                        apiTestResults.addAll(results.functionResults)
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error running tests", e)
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Test Execution",
                                                passed = false,
                                                message = "Error: ${e.message}"
                                            )
                                        )
                                    } finally {
                                        isTestRunning = false
                                    }
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = !isTestRunning
                    ) {
                        Text("Run All Tests")
                    }

                    // Barcode type test
                    OutlinedButton(
                        onClick = {
                            if (!isTestRunning) {
                                isTestRunning = true
                                apiTestResults.clear()

                                coroutineScope.launch {
                                    try {
                                        // Run just the barcode type tests
                                        val tester = ScannerApiTester(scannerManager)
                                        val results = tester.testBarcodeTypesUI()

                                        // Update the UI with results
                                        apiTestResults.clear()
                                        apiTestResults.addAll(results)
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error testing barcode types", e)
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Barcode Types Test",
                                                passed = false,
                                                message = "Error: ${e.message}"
                                            )
                                        )
                                    } finally {
                                        isTestRunning = false
                                    }
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = !isTestRunning
                    ) {
                        Text("Test Barcode Types")
                    }
                }

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    // Scanner settings test
                    OutlinedButton(
                        onClick = {
                            if (!isTestRunning) {
                                isTestRunning = true
                                apiTestResults.clear()

                                coroutineScope.launch {
                                    try {
                                        // Run just the scanner settings tests
                                        val tester = ScannerApiTester(scannerManager)
                                        val results = tester.testScannerSettingsUI()

                                        // Update the UI with results
                                        apiTestResults.clear()
                                        apiTestResults.addAll(results)
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error testing scanner settings", e)
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Scanner Settings Test",
                                                passed = false,
                                                message = "Error: ${e.message}"
                                            )
                                        )
                                    } finally {
                                        isTestRunning = false
                                    }
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = !isTestRunning
                    ) {
                        Text("Test Settings")
                    }

                    // Image capabilities test
                    OutlinedButton(
                        onClick = {
                            if (!isTestRunning) {
                                isTestRunning = true
                                apiTestResults.clear()

                                coroutineScope.launch {
                                    try {
                                        // Run the image capabilities tests
                                        val tester = ScannerApiTester(scannerManager)
                                        val results = tester.testImageFunctionsUI()

                                        // Update the UI with results
                                        apiTestResults.clear()
                                        apiTestResults.addAll(results)
                                    } catch (e: Exception) {
                                        Log.e(TAG, "Error testing image functions", e)
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Image Functions Test",
                                                passed = false,
                                                message = "Error: ${e.message}"
                                            )
                                        )
                                    } finally {
                                        isTestRunning = false
                                    }
                                }
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = !isTestRunning
                    ) {
                        Text("Test Image API")
                    }
                }

                // Добавляем кнопку для тестирования последнего изображения
                OutlinedButton(
                    onClick = {
                        if (!isTestRunning) {
                            isTestRunning = true
                            apiTestResults.clear()

                            coroutineScope.launch {
                                try {
                                    // Получаем последнее изображение через XCScannerWrapper
                                    val lastImg = XCScannerWrapper.getLastDecodeImage()

                                    if (lastImg != null) {
                                        val width = lastImg.width
                                        val height = lastImg.height
                                        val hasData = lastImg.data != null
                                        val dataSize = lastImg.data?.size ?: 0

                                        // Добавляем результаты
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Last Image Test",
                                                passed = true,
                                                message = "Got image: ${width}x${height}, data size: $dataSize bytes"
                                            )
                                        )
                                    } else {
                                        apiTestResults.add(
                                            FunctionTestResult(
                                                functionName = "Last Image Test",
                                                passed = false,
                                                message = "No image available - try scanning a barcode first"
                                            )
                                        )
                                    }
                                } catch (e: Exception) {
                                    Log.e(TAG, "Error getting last image", e)
                                    apiTestResults.add(
                                        FunctionTestResult(
                                            functionName = "Last Image Test",
                                            passed = false,
                                            message = "Error: ${e.message}"
                                        )
                                    )
                                } finally {
                                    isTestRunning = false
                                }
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isTestRunning
                ) {
                    Text("Get Last Image (Direct API)")
                }

                // Loading indicator
                if (isTestRunning) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp),
                        horizontalArrangement = Arrangement.Center,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(24.dp),
                            strokeWidth = 2.dp
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Running tests...",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }

                // Results display
                if (apiTestResults.isNotEmpty()) {
                    Divider(modifier = Modifier.padding(vertical = 8.dp))

                    Text(
                        text = "Test Results:",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )

                    LazyColumn(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(240.dp)
                    ) {
                        items(apiTestResults) { result ->
                            TestResultItem(result)
                        }
                    }

                    // Summary
                    val passedCount = apiTestResults.count { it.passed }
                    val totalCount = apiTestResults.size
                    val passPercentage = if (totalCount > 0) (passedCount * 100 / totalCount) else 0

                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Passed: $passedCount/$totalCount",
                            style = MaterialTheme.typography.bodyMedium
                        )

                        Text(
                            text = "$passPercentage%",
                            color = when {
                                passPercentage > 80 -> Color.Green
                                passPercentage > 50 -> Color.Yellow
                                else -> Color.Red
                            },
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun TestResultItem(result: FunctionTestResult) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Status indicator
        Surface(
            modifier = Modifier.size(20.dp),
            shape = CircleShape,
            color = if (result.passed) Color.Green else Color.Red,
            border = BorderStroke(1.dp, MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Box(contentAlignment = Alignment.Center) {
                Text(
                    text = if (result.passed) "✓" else "✗",
                    color = Color.White,
                    fontSize = 12.sp,
                    textAlign = TextAlign.Center
                )
            }
        }

        // Function name and result
        Column(
            modifier = Modifier.weight(1f)
        ) {
            Text(
                text = result.functionName,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.SemiBold
            )

            if (result.message.isNotEmpty()) {
                Text(
                    text = buildAnnotatedString {
                        if (result.passed) {
                            withStyle(style = SpanStyle(color = Color.Gray)) {
                                append(result.message)
                            }
                        } else {
                            withStyle(style = SpanStyle(color = Color.Red, fontFamily = FontFamily.Monospace, fontSize = 12.sp)) {
                                append(result.message)
                            }
                        }
                    },
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.alpha(0.8f)
                )
            }
        }
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/screens/SimpleImageViewerSection.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/ui/screens/SimpleImageViewerSection.kt
package com.xelth.eckwms_movfast.ui.screens

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import coil.size.Size

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun SimpleImageViewerSection(
    imageUrls: List<String>,
    modifier: Modifier = Modifier
) {
    if (imageUrls.isEmpty()) {
        return
    }

    // Create pager state
    val pagerState = rememberPagerState { imageUrls.size }

    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Server Images",
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Image pager
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(240.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(Color.Black.copy(alpha = 0.05f))
            ) {
                HorizontalPager(
                    state = pagerState,
                    modifier = Modifier.fillMaxSize()
                ) { page ->
                    val imageUrl = imageUrls[page]
                    SimpleImageItem(imageUrl = imageUrl)
                }

                // Image counter
                Box(
                    modifier = Modifier
                        .align(Alignment.BottomEnd)
                        .padding(8.dp)
                        .clip(RoundedCornerShape(4.dp))
                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = "${pagerState.currentPage + 1}/${imageUrls.size}",
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Pager indicator dots
            if (imageUrls.size > 1) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp),
                    horizontalArrangement = Arrangement.Center
                ) {
                    repeat(imageUrls.size) { index ->
                        val selected = pagerState.currentPage == index
                        Box(
                            modifier = Modifier
                                .padding(horizontal = 4.dp)
                                .size(if (selected) 10.dp else 8.dp)
                                .clip(CircleShape)
                                .background(
                                    if (selected)
                                        MaterialTheme.colorScheme.primary
                                    else
                                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
                                )
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun SimpleImageItem(
    imageUrl: String,
    modifier: Modifier = Modifier
) {
    val painter = rememberAsyncImagePainter(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .size(Size.ORIGINAL)
            .crossfade(true)
            .build()
    )

    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Image(
            painter = painter,
            contentDescription = "Server image",
            modifier = Modifier.fillMaxSize(),
            contentScale = ContentScale.Fit
        )
    }
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/theme/Color.kt ---

package com.xelth.eckwms_movfast.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/theme/Theme.kt ---

package com.xelth.eckwms_movfast.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun EckwmsmovFastTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

--- File: /app/src/main/java/com/xelth/eckwms_movfast/ui/theme/Type.kt ---

package com.xelth.eckwms_movfast.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

--- File: /app/src/main/java/com/xelth/eckwms_movfast/utils/PermissionUtils.kt ---

// app/src/main/java/com/xelth/eckwms_movfast/utils/PermissionUtils.kt
package com.xelth.eckwms_movfast.utils

import android.Manifest
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.rememberPermissionState

import com.google.accompanist.permissions.shouldShowRationale

@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun RequestCameraPermission(
    onPermissionGranted: () -> Unit,
    onPermissionDenied: () -> Unit
) {
    val cameraPermissionState = rememberPermissionState(Manifest.permission.CAMERA)

    LaunchedEffect(cameraPermissionState) {
        if (cameraPermissionState.status.isGranted) {
            onPermissionGranted()
        } else {
            cameraPermissionState.launchPermissionRequest()
        }
    }

    LaunchedEffect(cameraPermissionState.status) {
        if (cameraPermissionState.status.isGranted) {
            onPermissionGranted()
        } else if (cameraPermissionState.status.shouldShowRationale) {
            onPermissionDenied()
        }
    }
}

--- File: /app/src/main/res/drawable/ic_launcher_background.xml ---

<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>


--- File: /app/src/main/res/drawable/ic_launcher_foreground.xml ---

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>

--- File: /app/src/main/res/mipmap-anydpi/ic_launcher.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>

--- File: /app/src/main/res/mipmap-anydpi/ic_launcher_round.xml ---

<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>

--- File: /app/src/main/res/values/colors.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>

--- File: /app/src/main/res/values/strings.xml ---

<resources>
    <string name="app_name">eckwms-movFast</string>
</resources>

--- File: /app/src/main/res/values/themes.xml ---

<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Theme.EckwmsmovFast" parent="android:Theme.Material.Light.NoActionBar" />
</resources>

--- File: /app/src/main/res/xml/backup_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>

--- File: /app/src/main/res/xml/data_extraction_rules.xml ---

<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>

--- File: /app/src/test/java/com/xelth/eckwms_movfast/ExampleUnitTest.kt ---

package com.xelth.eckwms_movfast

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}

--- File: /build.gradle.kts ---

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false
}

--- File: /gradle.properties ---

# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true

--- File: /gradle/libs.versions.toml ---

[versions]
agp = "8.13.0"
kotlin = "2.0.21"
coreKtx = "1.15.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.8.7"
activityCompose = "1.10.1"
composeBom = "2024.09.00"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }



--- File: /gradle/wrapper/gradle-wrapper.properties ---

#Sat Apr 05 15:29:46 CEST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


--- File: /gradlew ---

#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"


--- File: /gradlew.bat ---

@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


--- File: /settings.gradle.kts ---

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()

    }
}

rootProject.name = "eckwms-movFast"
include(":app")

